\section{General Documentation}

\subsection{INTRO}

{\bf Introduction and some fast hints on the CD mudlib for LPmud 3.0}

Welcome to the CDmudlib. This mudlib was developed for Genesis mainly by the
following people:

    \begin{itemize}
    \item Johan Andersson (Commander)
    \item Carl Hallen   (Fatty)
    \item Jacob Hallen  (Tintin)
    \item Ronny Wikh    (Mrpr) and
    \item Tony Elmroth  (Banzai)
    \end{itemize}

There were also a lot of others that contributed in the design, among others,
Styles, Mort, Ultimate.

This mudlib was designed from scratch, with a specific intention not to care
about backwards compatibility. It is a break with the old so:

    DO NOT EXPECT YOUR OLD LPC OBJECTS TO WORK WITHOUT CHANGE

Here is a quick reference to what needs to be changed, it turns out that many
objects can be made to work with only minor adjustments.

{\bf General}

\begin{itemize}
\item  All objects MUST inherit "/std/object". They will be unusable if they do not.
\item All standard stuff, when cloned, should be configured with 'set\_' functions.
\item Errors are logged in the file 'log/errors' in your home directory.
\item The long() lfun now returns a string it does not do a write.
\item move\_object() will only move this\_object(), if you want to move an object
      you do: \\ ob-\verb+>+move(destination);
\item command() does not take a second argument, you do: player-\verb+>+command(cmd);
\item You need to look through all your say() and tell\_room() to make them use
      'reciever dependant messages', see "/doc/man/general/meet\_people" and the set
      of usefull macros in "/sys/macros.h"
\item The 'reset(0|1)' has been changed into create() and reset()
\item first\_inventory() and next\_inventory() has been replaced with
      all\_inventory() and inventory(ob,num)

\item The directory structure has changed. All Wizard files are under /d,
      the mudlib standard source are under /std, /global, /sys and /secure
      For more docs, see /DIR\_DOCS
\item All paths given and returned to efuns should have a leading '/'
\item Home directories are under /d, nothing is under /players anymore.
\item You can not use objects under /open and /ftp. You can create your own subdir
      "open" in your homedirectory. This will be readable by all.

\item All your commands is displayed with the 'allcmd' command.
\item Use the commands: 'info', 'help' and 'man' for more documentation.
\end{itemize}

{\bf Reset / Create}

There is two important changes to reset. When objects are loaded/cloned it
is NOT reset, but create, that gets called and without argument. So instead of
calling reset(0) for construct and reset(1) for resetting, create() is called
for construct and reset() is called for resetting.

The reset/create scheme in CDmudlib is somewhat complex, but fairly straight
forward. Basically, if you inherit something under /std you should not have two
functions called 'create' and 'reset', they should be called 'create\_something'
and 'reset\_something', where something is what you inherit, examples:

\begin{verbatim}
    inherit "/std/room";     create_room() { ....
    inherit "/std/object";   create_object() { ....
    inherit "/std/weapon";   create_weapon() { ....
            ..... etc ....
\end{verbatim}

And likewise with reset\_(). You need not worry about any ::create() this is
all taken care of. You do only what YOU need to do.

NOTE again, you will probably use only 'create\_something' in 90\% of
your objects.

{\bf Rooms}

\begin{itemize}
\item Rooms should inherit "/std/room". The create is called 'create\_room'
\item Common functions:  set\_short("short desc"), set\_long("long desc") and \\
  add\_exit("/roompath","dir",0); Do: 'man add\_exit' for docs on 3 param.
\item Instead of affect\_environment there is now: add\_my\_desc() which can be
  called without having an object in the room doing the call. The description
  will remain as long as the object is not destructed, wherever the object
  is located.
\end{itemize}

{\bf Objects}

\begin{itemize}
\item You MUST inherit "/std/object", the create is called 'create\_object'
\item You need to change your 'create' routine as above
\item There is no special lfuns like 'get', 'drop', 'can\_put\_and\_get' instead
  properties are used, see "/sys/stdproperties.h", among these are
  OBJ\_I\_NO\_DROP and OBJ\_I\_NO\_GET.
\item There is a lot of features in /std/object that you CAN use. You do not
  have to though. You can define your own short(), id(), long() etc and
  they will work fairly well. Player commands like 'get all the blue ones' will
  however not work well with your object in this case.
\end{itemize}

{\bf Weapons}

\begin{itemize}
\item Weapons will not work in combat unless they inherit "/std/weapon"
  For more docs see 'weapon'
\end{itemize}

{\bf Armour}

\begin{itemize}
\item Armours will not work in combat unless they inherit "/std/armour"
  For more docs see 'armour'
\end{itemize}

{\bf Features}

\begin{itemize}
\item There is a VERY powerful feature called 'value by function call'. Almost
  all the set\_ functions in the standard objects can take a special value on
  the form "@@functionname". Examples:

\begin{verbatim}
    set_long("@@my_longfunc");
    add_exit("@@current_room_north","north",0);
\end{verbatim}

  What happens is that everytime the value is used, for set\_long() this is 
  when you call long(), intead of returning the value directly, the value
  is interpreted as a function name and that function is called. What the
  function returns will be the actual return value from, in this example, 
  long(). This is a general method to let things 'change on the fly'.

  You can have functions called in other objects too, do 'man check\_call'

\item Messages given by say() and tell\_room() are reciever dependant. This means
  that a function 'catch\_msg' is called for each living that is to recieve
  the message.

  This is used to implement 'nonmet' players. This feature combined with
  'value by function call' gives you the possibility to let different
  players get different messages depending on their status.

  One example of use is to implement languages for the races. You could make
  a player only understand what a player of the same race says.

\item There is a security system. This means that your objects now have the
  exact same rights that you yourself have. If you have write access somewhere
  then all your objects do to, whether you are logged in or not.

  There are some special considerations concerning the security system if you
  intend to make wiztools usable, and clonable, by other wizards. What it
  comes down to is that they have to use the command 'trust object' on your
  tool after they cloned it, unless they make a small object of their own that
  inherits your object.
\end{itemize}

\subsection{INTRO\_RULES}

The Lpmud game is very complex. Virtually any situation or idea may be
put into code. Because of this there has to be rules that defines what
a wizard may do and what he may not do.

Since the potential of the game is so great, we have endeavored to
separate the rules into sections that relate to just a single subject.
However there are some very general rules relating to all wizards that
can't be put solely into one of these subjects. They relate to all and
all must follow them. It is those rules you will find in this section.

{\bf Rules for all wizards}

As you became a wizard, the game as such came to an end. Accept that
now and you will have no trouble in the future. You are no longer a
part of the ordinary quest for experience and should have no such 
contact with the game in the future.

A wizard may not help or harass a player in the game. The only help a
wizard may offer is information on how to play the game, i.e. how the
mechanics of the game work, which commands are available etc. Hints
on quests, where to find equipment etc is expressly forbidden. Any
restorations or modifications of experience or equipment etc should be
handled by the Archwizards. Socializing is acceptable only if it is
made on the terms of the mortal in question. Their right to privacy
and enjoyment of the game must be respected.

All wizards have a test character available in the game. The name of
that test character is the same as the wizard but with a "jr" appended.
You can log this test character on as soon as you become wizard by
using the same password as your normal character. If there should be a
need for more than one test character, be certain to make him
immediately identifiable as a testcharacter by his name. This
testcharacter must be played as if he were a wizard, with the same
rules applying to him. A wizard may not introduce a "test wizard".
All test characters must be mortals. 

You are supposed to use your test character to test out any code you
produce before making it available to the mortals. On \_NO\_ account may
you invite a mortal to test your area. This invariably ends with the
mortal being killed, loosing equipment and you getting demoted for
carelessness.

All code produced must of benefit to the game. A wizard may not write
code that is intended to harass another player or wizard. Code that
is intended to be of use to only a small number of people, like wizard
tools or special wizard rooms should be kept to an absolute minimum.
Be sure that you can motivate it before writing it. Ego-inflating code
like unique wizard-weaponry or armour etc is not allowed. We can use
the diskspace in a far more productible way even if you can't.

The game is set in "the long distant past". Because of this all
descriptions and messages of \_any\_ kind in the game should give the
player the feeling of a medieval setting. There simply may not exist
anything that even remotely sounds modern, not even in places where a
mortal never may see it.

{\bf Breaking of rules}

Generally if you break a rule this leads just to a warning and the
demotion of one or more levels. Remember though, that when you loose
your last level you will find yourself back in the game as a very novice
mortal and you will have to play your way back up to wizardhood again.

If the offense is considered to have been sheer hooliganism you might
be expelled from the game entirely. In case of such a drastic action,
the Archwizards must also consider possible actions of revenge from
you and they might deem it necessary to exclude your site entirely
from the game. 

{\bf Specific rules for the game}

All rules concerning the game as such may be found in the other files
in this directory. It's a very good idea to read through them all once
just to get an idea of what is allowed and not. Later when you want to
add things to the game you can read through the relevant files more 
carefully. Remember that not knowing about a rule is \_no\_ excuse for
breaking it.


\subsection{README}

{\em 3.0... What changed?}

{\bf Introduction}

I wrote this doc, to help people who have absolutely no experience in
programming LPC 3.0, or with the 3.0 mud itself. I hope that you will
be enlightened in the use of 3.0 and that you can make simple 3.0
objects after you have read this doc.
   I will divide this doc into several chapters, so you can quickly
find the things you are interested in. In this document, when some-
thing is between brackets (\verb+<+...\verb+>+), it means that it is required to
fill in the piece between the brackets in your command with something
that makes sense. If something is between braces ([...]) it means
that that part is optional, and can be left out.

                                                   Tricky

{\bf The 3.0 mud}

There are a few commands that really are interesting in 3.0, of which the
most important ones are probably:

\begin{itemize}
\item allcmd          Shows all your commands.

\item help \verb+<+cmd\verb+>+ Shows often help on the command
                    \verb+<+cmd\verb+>+.

\item man [-s] \verb+<+fun\verb+>+ Searches for help on the function
                    \verb+<+fun\verb+>+.  If the
                   -s flag is specified, the sources are also scanned
                   for help on the subject.

\item ed \verb+<+file\verb+>+ Edit a file.  Most of the help on the editor can be
                   obtained within it! Try "h", or "?" in the editor.
                   NOTE: you don't have to do your editing in Ed, if
                   you can ftp, try this: \\ "ftp 129.16.48.2", use the
                   login "lpmud:\verb+<+yourname\verb+>+" and your own mud-password.
                   Then you can use "[m]put" and "[m]get" to transfer
                   files to and from your own directory. That way, you
                   can use the comforts of your home editor.

\item cp \verb+<+from\verb+>+ \verb+<+to\verb+>+ Copy the file
                \verb+<+from\verb+>+ to the file \verb+<+to\verb+>+.  The file
                \verb+<+to\verb+>+
                   has to be a path with a filename appended. cp doesn't
                   put files automatically in a directory, like the Unix
                   cp would do.

\item mv \verb+<+from\verb+>+ \verb+<+to\verb+>+ Move (rename) the file
                \verb+<+from\verb+>+ to the file \verb+<+to\verb+>+.  The
                   file \verb+<+to\verb+>+ doesn't have to be in the same directory
                   as \verb+<+from\verb+>+.

\item rm \verb+<+file\verb+>+       Remove (delete) the file \verb+<+file\verb+>+.

\item sanction \verb+<+flags\verb+>+ \verb+<+who\verb+>+ Allow/disallow someone
                to read/write in your
                   own directory or to snoop you.

\item start here      Set your startup-place. I like to start in the privacy
                   of my workroom, instead of in the crowded church.

\item title           Set your title.

\item adjdesc         Set your adjective description.

\item altitle         Set your alignment title.

\item busy [flags]    This command sets your busy level. There are too many
                   flags to explain them all here. Let me just say that
                   it is possible to make yourself completely deaf with
                   this command.
\end{itemize}

Well, those were by far not all commands, but these are the most basic ones.
If you want to know more, use "allcmd" to find out your commands, and then
ask "help" on one of them.

{\bf Directories under 3.0}

The paths under 3.0 have changed radically. I will point out what the
interesting directories are.

\begin{itemize}
\item{\bf /doc}
      This directory contains only subdirectories. As the name suggests,
      those directories are filled with docs.

\item{\bf /doc/man/efun}
      This directory contains all manuals for the external functions that
      are provided by LPC. If you search for a function that is not specific
      for any object in particular, look in this directory.

\item{\bf /doc/man/lfun}
      This directory contains all manuals for the local functions of some
      objects that are often inherited. There is a lot to be found in here!

\item{\bf /doc/man/lfun/living}
      In this directory you will find functions that are defined for each
      living creature.

\item{\bf /doc/man/lfun/player}
      Same for each player object. You will typically find here how to
      add experience to a player, or set special player-things.

\item{\bf /std}
      This directory contains all objectfiles that need to be inherited
      if you make an LPC object. Multiple inheritance is allowed in LPC,
      but usually inheriting one objectfile will suffice. Inherit eg.:
         - object.c       for generic objects, like a painting
         - monster.c      for a monster, like an orc
         - food.c         for food, like bread
         - drink.c        for a drink, like brandy
         - container.c    for a container, like a bag
         - coins.c        for money
         - armour.c       for amours, like a chainmail
         - weapon.c       for weapons, like a two-handed broadsword.

\item{\bf /open}
      The open directory. You have write access here, but I beg you
      not to use it, unless you know for sure that you should use it.
      There is no real need for this directory, as you can see below.

\item{\bf /sys}
      In this directory you will find almost all of the includes that are
      interesting to include, such as:
         - macros.h        (handy macros),
         - stdproperties.h (standard properties of all kinds of things),
         - wa\_types.h      (weapon and armour types),
         - ss\_types.h      (standard skill types),
         - formulas.h      (standard conversion formulas).

\item{\bf /secure}
      This directory is not really interesting for you, but maybe you
      will need the file std.h. The file simul\_efun.c may be of some
      interest too.
      The directory contains code for the administration of the game.

\item{\bf /cmd}
      This is where the code for the souls may be found. It's not of
      very great interest.

\item{\bf /d}
      In this directory all the domain directories are located. As you
      probably have noticed, all domains start with a capital, whereas
      wizardnames start with a lowercase letter. If a wizard has a
      directory, but is not in a domain, he is automatically in the Wiz
      domain.
 
\item{\bf /d/Wiz}
      This directory is the home of the braves. Most of the keepers and
      arches have their directories in this directory. You will probably
      not be able to read any files in them ;-).
      However, it might be worth the trouble to look at things that
      these wizards keep in their open libraries.

\item{\bf /d/\verb+<+Your\_domain\verb+>+}
      In this directory is your directory located. You have read access
      to all files and directories in this directory.

\item{\bf /d/\verb+<+Your\_domain\verb+>+/\verb+<+your\_name\verb+>+}
      Yep, this is your directory. You have read and write access to it.

\item{\bf /d/\verb+<+Your\_domain\verb+>+/common}
      This is the common directory of the domain you're in. Every wizard
      in the domain has write-access on it. That can be real handy if
      someone wants to debug your stuff when you are away.

\item{\bf /d/\verb+<+Your\_domain\verb+>+/open and
   /d/\verb+<+Your\_domain\verb+>+/\verb+<+your\_name\verb+>+/open}
      Everyone (including people outside your domain) has read-access to
      these directories. That is why you don't need to write in the /open
      directory, simply put your open stuff in your own open directory!

\item{\bf /d/Genesis}
      This is the domain that contains all startup-areas of all races,
      the wiz-area, the race-specific souls and much more. All directories
      can be read by you.
\end{itemize}

These were the most interesting directories. You probably cannot write in
most of them. This rule does not apply to all people. Lords can write in
every directory in their domain, arches and keepers can write everywhere
they please. Note that you can allow other wizzes to read and/or write in
your own directories by doing "sanction [R][W] \verb+<+name\verb+>+", or by simply
putting the stuff you want them to examine in your open directory.

So much for the introductory part, let's get down to the serious business:

{\bf LPC 3.0}

Some fear it, some think it is impossible, others adore it. I don't know.
For those of you who know LPC 2.4.5 (or 2.4.6), it hasn't changed that much.
Of course there are lots of new functions defined by LPC 3.0, but they are
implemented because they make your life easier. All that is written below
is made with the intention to enable you to make simple objects in LPC 3.0.
If you want to make advanced objects, ask someone who knows about it. You'd
better try to make some simple objects at first, and then try to improve
them.

As Commander wrote in his INTRO doc, all objects will inherit something.
The file that is being inherited is called /std/xxxx. The first function
you define in your object, in which you will probably set the name, the
long description and the short description, is called "create\_xxxx", where
xxxx is the name of the object you inherited. The function "create\_xxxx"
will be called the first time the object is loaded or cloned.

Every half hour, the mud will send a reset signal to all its objects. Then,
the function "reset\_xxxx" will be called. So, if you want to refresh your
guards periodically in a room, so it will not stay unguarded too long, the
"reset\_room" function is a good place to put a check in.
( Every half hour isn't exactly true. It is that at the present, but
  may be changed at any time to adjust the ammount of stuff in the game.
  /Note by Tintin )

The last interesting function is "init". This function will be called
every time a living creature comes 'in sight' of an object. Eg. if the
object is picked up, if a monster enters the same room, if an object is
taken out of a bag, its "init" will be called. Some objects require that
you put a line "   ::init();" in the "init" function. Typically, you will
add commands to a player in the "init".

There are a few basic objects that I will explain here. Of course that will
not be all objects, but the most interesting ones. I hope that the examples
have some didactic value.

{\bf ROOM.C}

This is probably the most interesting object, since it is the one you will
create most often. This is what the world is made of. Let's make a simple
room.

\begin{verbatim}
   inherit "/std/room.c";

   #include "/sys/stdproperties.h"

   create_room() {
      set_short("Entrance");   /* This will show up when the player is in */
                               /* "brief" mode.                           */
      /* Set the long description of the room */
      set_long(break_string(
         "There is something very peculiar with this room... It is "
       + "cube-shaped, yet it has no corners! You wonder what sorceror "
       + "would make up such a mind-boggling kind of room... Luckily "
       + "you can escape to the south.\n",70));

      add_exit("/d/Genesis/start/human/church", "south", 0); /* add exit */

      /* Make the corner examinable */
      add_item(({ "corner", "round corner", "edge" }), break_string(
         "You desperately search for a corner, but you cannot locate one. "
       + "How is this possible? You are starting to get a headache.\n", 70));

      add_prop(ROOM_I_INSIDE, 1); /* This is an indoors room */
      change_prop(ROOM_I_LIGHT, 0); /* Make the room dark */ 
   }
\end{verbatim}

That was the room... As you can see, I used the break\_string("...",70)
technique to make sure that the string is cut into lines of length \verb+<+ 70
characters. The same technique is used with add\_item. Note that it is
possible to give either one string, or an array of strings as first
argument to add\_item. The given description will be shown every time a
player wants to look at the identifier string.
The add\_exit function has three arguments: The filename of the room that is
connected to this room, the command that will get you there and the third
argument is an optional VBFC function (explained below). If that function
returns 1, the exit cannot be taken. If the function returns 0, the exit
can be taken.

{\bf OBJECT.C}

Let's say you want to make a light-bulb. This is typically an generic object.
This is what the code would look like:

\begin{verbatim}
   /* A light bulb */

   inherit "/std/object";

   #include "/sys/stdproperties.h"  /* We want to use standard properties */

   create_object() {
      set_name("bulb");           /* The id of this object   */
      set_pname("bulb");          /* The plural id           */
      set_short("light bulb");    /* The short description   */
      set_pshort("light bulbs");  /* Plural short descr.     */
                                  /* Long description        */
      set_long("This lightbulb is now more like a dark bulb.\n");
      add_prop(OBJ_I_WEIGHT,75);  /* Set weight property to 0.075 Kg  */
      add_prop(OBJ_I_VOLUME,200); /* Set volume property to 0.200 Ltr */
   }
\end{verbatim}

That was all! You could leave out the add\_prop(...) part, but then the
light bulb would weigh 1 Kg and measure 1 Ltr. This goes for all properties:
if you don't set them specifically, they will take a standard value. You
can also leave out the set\_pname and set\_pshort part, but then the parser
will try to make its own plural, which you might not like. Eg. when I
cloned another "test version of the pipe of the Shires", I suddenly
carried "two test versions of the pipes of the Shireses"...

{\bf CONTAINER.C}

This is a more tricky object, because it does not only have its own volume
and weight, but can also hold a specific volume and weight. Let's say you
want to make a nightstand:

\begin{verbatim}
   /* A nightstand */

   inherit "/std/container"

   #include "/sys/stdproperties.h"

   create_container() {
      set_name("nightstand");
      set_short("crummy old nightstand");
      set_pshort("crummy old nightstands");
      set_adj(({"crummy","old"});      /* extra adjectives, the player    */
                                       /* can now do "exa old nightstand" */
      set_long("The crummy old nightstand will probably not last long.\n");
      add_prop(CONT_I_WEIGHT,     20000);   /* It weighs 20 Kg            */
      add_prop(CONT_I_MAX_WEIGHT, 27000);   /* It can contain up to 7 Kg  */
      add_prop(CONT_I_VOLUME,     14000);   /* It measures 14 Ltr         */
      add_prop(CONT_I_MAX_VOLUME, 17000);   /* It can contain 3 Ltr       */
      add_prop(CONT_I_RIGID, 1);            /* It is a rigid object       */
   }
\end{verbatim}

As you notice, the MAX\_WEIGHT and MAX\_VOLUME are the WEIGHT and the VOLUME
plus what they can contain. The nightstand cannot change shape, so it is
defined RIGID. A bag would typically not be rigid, unless it has been washed
with too much paste ;-).

{\bf MONSTER.C}

These babies can do a lot. I myself am not quite aware of all their capabili-
ties, but there sure are a lot. I will only show how to make a really simple
talking monster. Let's make an ugly nazgul by the name of Dschik.

\begin{verbatim}
   /* Dschik, the ugly nazgul */

   inherit "/std/monster";

   #include "/sys/std_properties.h"
   #include "/sys/ss_types.h"

   create_monster() {
      set_name("dschik");
      set_race_name("nazgul");
      set_adj("ugly");
      set_short("ugly nazgul");
      set_pshort("ugly nazguls");
      set_long("Nazguls are ugly, but this one is one of the uglier types.\n");

      default_config_npc(11);   /* Make him a standard monster with 11 in
                   all stats */
      set_base_stat(SS_CON, 8); /* Set his CON to 8, ie. a max of 64 hp */
      set_hp(50);               /* He starts at 50 hp, but slowly heals */

      set_chat_time(10);      /* Set the time between speaking    */
      add_chat("Go away!");   /* Add some lines to say (randomly) */
      add_chat("Who are you?");
      add_chat("Go hither, foul creature!");
   }
\end{verbatim}

This really is the most basic monster you can possible make. There are much
more intersting features of monsters, such as making them do sequences of
actions, letting them react to the outside world etc., but I won't discuss
them here. Notice that I don't set the WEIGHT and VOLUME properties, so
they will be set to 70 Kg and 70 Ltr.

{\bf ARMOUR.C}

Of course you don't want your monsters to run around unprotected against the
violent players. Therefore you wish to give them good armours. On the other
hand: too many good armours will devaluate all armours. So, be reluctant in
making good armours. I think the general rule is this: don't make very good
armours, unless you make a very strong monster. Good armours should be tough
to obtain.
Here is an example of a blue platemail.

\begin{verbatim}
   /* A blue platemail */

   inherit "/std/armour";

   #include "/sys/wa_types.h"    /* Weapon and armour types        */
   #include "/sys/formulas.h"    /* Some handy conversion formulas */

   create_armour() {
      set_name("platemail");
      set_short("blue platemail");
      set_pshort("blue platemails");
      set_long("The blue platemail is heavy and doesn't look magical.\n");

      set_default_armour(
         19,          /* Armour class */
         A_BODY,      /* Armour type  */
         0,           /* Armour/weapon modifier list (?)     */
         0);          /* Object that defines wear and remove */

      add_prop(OBJ_I_WEIGHT, 11000); /* 11 Kg. Well, it is a platemail... */
      add_prop(OBJ_I_VOLUME,  1380); /* An iron platemail (see table)     */
      add_prop(OBJ_I_VALUE, F_VALUE_ARMOUR(19) + random(200) - 100);
                  /* Standard formula to calculate value with given ac */
   }
\end{verbatim}

I think this platemail is selfexplanatory... It is a body armour, when worn
is provides a protection of ac 19, then the value is set to the standard
formula for an armour of ac class 19. The value is randomized a bit, so the
players will not be able to judge an armour by the price it has. With this
construction, it will be max 100 coins more or 100 coins less than it should
be.

{\bf WEAPON.C}

With these objects you can arm your monsters. The same goes here, as with
the armours: don't make too strong weapons, for it will cause inflation.
If you have a good reason to make a strong weapon, then don't. There are
probably hundreds of other people with similar ideas, and they all have
the same conviction that you have. So, keep it to bad/mediocre/fairly good
weapons. Don't forget: there are more ways to make a good weapon other than
making its weapon class high; you could make an aluminum sword, which would
be very light.

\begin{verbatim}
   /* A copper katana */

   inherit "/std/weapon";

   #include "/sys/wa_types.h"    /* Weapon and armour types        */
   #include "/sys/formulas.h"    /* Some handy conversion formulas */

   create_weapon() {
      set_name("katana");
      set_short("copper katana");
      set_pshort("copper katanas");
      set_long("The copper katana looks like it can slice things easily.\n");

      set_default_weapon(
         19,      /* Weapon hit (see /sys/wa_types for max.)      */
         33,      /* Penetration (see same file for max)          */
         W_SWORD, /* Weapon type                                  */
         W_SLASH | W_IMPALE,  /* Damage type                      */
         W_NONE,  /* A one hand weapon, free to choose which hand */
         0);      /* The object defining the (un)wield functions  */

      add_prop(OBJ_I_WEIGHT, 5000); /* 5.0 Kg   */
      add_prop(OBJ_I_VOLUME,  560); /* 0.56 Ltr */
      add_prop(OBJ_I_VALUE,F_VALUE_WEAPON(19,33) + random(130) - 65);
                  /* Standard formula to calculate value with given wc's */
   }
\end{verbatim}

{\bf VBFC}

This is one of the neatest new possibilities of 3.0. Instead of filling in
what a function needs, you fill in "@@my\_func", where my\_func() returns the
desired value. This means that my\_func() can return a value that is dependant
of the status when the function is called. Let's give a simple example:

In the previous weapon, I change the set\_long line to this:

\begin{verbatim}
      set_long("@@dependant_long");
\end{verbatim}

And I add this function to the code:

\begin{verbatim}
   dependant_long() {
    /* Check if the person who is carrying the weapon is human */
      if (environment(this_object)->query_race() == "human")
         return "The copper katana has a firm grip in human hands\n";
      else
         return "The copper katana looks like a standard weapon.\n";
   }
\end{verbatim}

Every time someone examines the object, the function dependant\_long() will be
called. This function then checks if its carrier (if any) is of the human
race. If so, another long than usual is returned. Virtually all the standard
set\_... functions support the usage of VBFC. It is a very powerful feature,
which will often come in handy.

{\bf ARRAYS}

Arrays have become very powerful in LPC3.0. There are many new functions that
support the use of arrays. Let me first explain what an array looks like in
LPC: (\{ a, b, c \}) is an array with 3 elements, a, b and c. these elements
can be of any type: integer, string, object or even array. Arrays can simply
be added like this: ({ "foo" }) + ({ "bar" }) gives ({ "foo", "bar" }).

Here are a few array functions that are very handy:

\begin{itemize}
\item{\bf explode\_string(str1, str2)}
         This function returns an array that consists of the loose strings
         that come into existence after the string str1 is divided in parts
         by cutting on every occurence of str2. Eg. if you did
         explode\_string("Humpty Dumpty fell off a wall.", " "), you would get
         ({ "Humpty", "Dumpty", "fell", "off", "a", "wall." })

\item{\bf implode\_string(arr, str)}
         This function returns a string that is made of all elements of the
         array arr, with the string str placed between them. Eg.:
         implode\_string(({ "foo","bar","zukini." }), " and ") would return
         "foo and bar and zukini."  

\item{\bf slice\_array(arr, from, to)}
         This function returns a piece of an array from element from to
         element to.

\item{\bf filter(arr, fun, obj)}
         This function returns an array with all elements in it for which the
         function fun in object obj returned 1. The elements for which 0 was
         returned are left out. fun is the function name, enclosed in quotes.

\item{\bf map(arr, fun, obj)}
         This function returns an array in which all elements have been
         replaced by whatever the function fun in the object obj returns
         for each element. fun is the function name, enclosed in quotes.

\item{\bf sort\_array(arr, fun, obj)}
         This function returns the sorted version of arr, by using the
         function fun in object obj as less-equal function. Say eg., you
         want your array of strings to be sorted alphabetically. The you
         would make a function str\_less\_eq() like this:

        \begin{verbatim}
            str_less_eq(a,b) { return a <= b; }
        \end{verbatim}

         And then you would do:

        \begin{verbatim}
            arr = sort_array(arr, "str_less_eq", this_object());
        \end{verbatim}

         Et voila! An alphabetically sorted array.
\end{itemize}

{\bf Interesting documents:}

\begin{itemize}
\item{\bf /doc/man/general/*}
    The files in this library explain a great deal about
    everything that is new.
\end{itemize}

{\bf Constants for different metals}

It is not obliged to make things look real, but to get a feeling, here are
the actual values for the Rho of several kinds of metal, where

\begin{verbatim}
            Weight = Volume x Rho.

   Metal            Rho            Alloy           Rho
--------------------------      -------------------------
   Aluminum         2.7            Bronze           8.9
   Chrome           7.1            Cast iron        7.3
   Gold            19.3            Brass            8.5
   Lead            11.3            Steel            6.9
   Magnesium        1.7            Stainless steel  7.8
   Copper           8.9
   Platinum        21.4
   Tin              7.3    Example: If you think your gold helmet weighs
   Iron             7.9     about 2000 grams, then it will measure 2000/19.3
   Silver          10.5     = 103 ml.
   Zinc             6.9
\end{verbatim}


\subsection{armour}


This is a preliminary guide for the creation of armours. Armours are all
objects that inherit '/std/armour'.

An armour is basically configured with three parameters:

\begin{itemize}
\item{\bf Armour type:}
            This indicates what part of the body that the armour
            protects. There is a given number of 'slots' for which
            a player can wear an armour. There can not be more than
            one armour for each slot. For types see table below.
        
            {\em It is currently not possible to have a multitype armour}

\item{\bf Armour class:}
            This is a relative value for the quality of the armour.
            All armour types can have ac values from 0-100. Certain
            types cover the same part of the body giving protection
            against a hit at that part with more than ac100. In such
            a case the summed ac value for the body part is set to
            100.
    
            Below is a list of maximum ac values gainable in different
            situations:

    Maximum values for all armour classes independant of armour type

\begin{verbatim}
    Max AC found (on the ground)    :  10
    Max AC bought                   :  30
    Max AC conquered (in combat)    :  60
    Max AC reward for solving quest :  20 * questlevel (see xp_scale)
\end{verbatim}

    Even though armour gained through combat can be up to ac60, only a
    major foe do have such armament. Use your common sense :-)

\item{\bf Armour modifier:}
            This indicates an armours sensitivity to certain types
            of attacks, ie damage types. The armour modifier is an
            array holding a modify value for each damage type.

            There is currently three damage types:
            IMPALE, SLASH, BLUDGEON

            This means that the armour modifier is an array, for ex.:
            (\{ -2, 3, 0 \}) would be -2 for impale damage and +3 for slash damage.
            Note that the maximum limits still apply.

The base value in copper coins of an armour is calculated with the formula:

            $cc = 50 + (ac * ac * 2)$

Note that the ac should reflect the average ac and the modifiers
should average out to 0. For example if you want a coarse chain mail with
slash-ac 40 and impale-ac 20. You would give ac = 30 and am = (\{ -10, 10, 0 \})

\begin{verbatim}
       Table of armour slots <-> Hitlocations

             TORSO HEAD LEGS R_ARM L_ARM

    TORSO      X      
    HEAD            X
    LEGS                 X
    R_ARM                      X
    L_ARM                            X
    ROBE       X         X                
    SHIELD                     X     X                          

    any magical armour
               X    X    X     X     X      
\end{verbatim}
\end{itemize}

\subsection{boot\_world}

DO NOT CHANGE THIS FILE! IT HAS ALREADY BEEN INCORPORATED IN THE GLOBAL
DOCUMENTATION. CHANGE LPmud.texinfo INSTEAD.

This document describes how the world is booted up in 3.0.

Booting the world is the process of starting the Gamedriver and preload all
relevant gamedata, before users are allowed to connect to the game.

{\bf Booting in earlier versions of LPmud}


In versions of LPMud earlier than 3.0, booting was done by first starting the
gamedriver and then preload all objects listed in a file: /room/init\_file
This file was basically a list of all the castles, one per wizard, in the game.

{\bf Booting in version 3.0-}


When the gamedriver is started up, one object is loaded:

    /secure/master.c

When this is done and the create() in it has been called, the gamedriver
checks for special options given with the '-f' flag from commandline when 
the process was started (see /secure/master.c)

When ready, the actual preloading begins. This is done by a call to the
epilog() function in /secure/master.c It returns an array of possible 
filenames to preload. The GD then calls the function preload() in 
/secure/master.c with each of these filenames. 

When the array of filenames to preload is exhausted the gamedriver starts to
allow users to connect to the game.

All connects to the game is handled by a call to the function connect() in
/secure/master.c This function returns the object that should be connected
to the user. This is a special 'login' object that handles the login procedure,
such as name and password queries. It also takes care of new players. When
the 'login' object is done it connects the user to the actual player object.
This can be different from player to player, depending on such things as race,
occupation, guild etc. The player is then moved to a start location.

{\bf Preload files returned by epilog()}


/secure/master.c holds a list of all the domains and all the wizards in the
game. This list is consulted by epilog() so that one object for each domain
and one object for each domain-less wizard gets preloaded. The filenames of 
these objects are:

\begin{verbatim}
    /d/Domain\_name/common/preload.c \\
    /d/Wiz/wizard\_name/preload.c
\end{verbatim}

There is one important consideration in the scheme of preloading. In 3.0 the
gamedriver keeps track of who is responsible for which objects. This is done
by having a userid and an effective userid connected to each object. An objects
userid is inherited from the effective userid of the object forcing its load.

/secure/master.c sets its effective userid to each domainlord and wizard
before loading each such 'preload' object. This must also be done by the
preload object of a domain if it wants to preload objects made by its
member wizards. This is down by the efun: seteuid(wizard\_name) before forcing
a load of that wizards preload object.

This is the only time you need to care about userid's unless you plan to make
wizardtools or make rooms without inheriting /std/room.c



\subsection{combat}

This file documents the principles behind the combat system. Specific
details of weapon and armour class values are found in ('weapon' and 'armour')

{\bf Basics}

Combat is managed automatically when initialized by a 'kill' command. As long
as the parties engaged in combat is in the same location the fight continues.
If one part leaves the other will attack the 'fleer' on sight, ie next time
they are in the same location. 

The principle is 'once my enemy, always my enemy'. If I die I forget my 
enemies, but they do not forget me! I keep a list of all my enemies, those
I 'hunt'. 

I may choose any object in the game as an enemy by attacking it. Animate ones
will fight back and inanimate will very likely take no notice. It is possible
though to give 'breakable' stuff such as glass cages, doors etc. hitpoints,
armour classes etc, and let them be fought.

All animate objects can do one round of fighting each heartbeat.

{\bf Generic combat elements}

There are two generic elements for all combat:

\begin{itemize}
    \item  Attacks
               Each heartbeat an animate object can make a certain number
           of attacks on its current enemy. 
    \item  Hitlocations
               An object can be divided into hitlocations with independant
           vulnerability. 
\end{itemize}

For more complicated creatures there is also a concept of combat tools. Each
tool occupies a so called, 'tool slot'. A creature can only have one tool for
each of its 'tool slots'. The tools are divided into two cathegories:

\begin{itemize}
    \item  Weapon tools
        These aid attacks, both the chance to hit and the capability
        to make damage. One attack can only be aided by one weapon,
        however, one weapon can aid many attacks.
    \item  Armour tools
        These affect the effective ac for one or many hitlocations of
        a creature. Armours can aid one or many hit locations and one
        hit location can be aided by one or many armours.
\end{itemize}

Note that both weapons and armours compete for the 'tool slots'. This means
for example that if a knife takes the 'right hand'-slot then a shield meant
to be held in the right hand can not be used.

For most creatures, these attack lists and hitlocation lists can be configured 
almost arbitrarily.  For humanoid creatures such as players and npc's, there
is a specific set of attacks and hitlocations predefined. In addition, for 
players and player emulating monsters it is not possible to add any more
attacks or hitlocations.

{\bf Implementation}

The combat system is implemented outside the actual living object in a
special 'combat object' which is linked to the living object and never
moved into an environment. It does NOT shadow the living object.

It is possible for a living object to decide what file to use as combat object,
all combat objects must however inherit '/std/combat/cbase' which is the
generic external combat object.

The specific details for configuring humanoids and creatures are given in
'humanoid\_combat' and 'creature\_combat'.

The generic combat as implemented in /std/combat/cbase is described below:

   Attacks (attacks are kept in a list of maximum 10 elements)
    
    Each attack is characterized by five values:

\begin{verbatim}
          att_id:    Specific id, for humanoids W_RIGHT etc
            wchit:     Weapon class 'to hit'
            wcpen:     Weapon class penetration
               dt:     Damage type
             %use:     Chance of use each turn
\end{verbatim}

   The attack id is essentially only a label. It is used to reference
   a specific attack and can be any integer value. For humanoids it
   is however predefined to be hands and feet (see /sys/wa\_types.h).

   wchit, wcpen and damage type are parameters documented in 'weapon'.
     
   The \%use is a parameter that gives the chance that the living object
   will use this attack a specific round. This can be used to let for
   example a dragon attack with 'breath' one time out of five (\%use = 20)

   Hitlocations (hitlocations are kept in a list of maximum 10 elements)
    
    Each hitlocation is characterized by four values:
    
\begin{verbatim}
        hit\_id:    Specific id, for humanoids, A\_TORSO, A\_HEAD etc
             ac:    The ac's for each damagetype
           %hit:    The chance that a hit will hit this location
           desc:    String describing this hitlocation, ie "head", "tail"
\end{verbatim} 

     The hitloc. id is essentially only a label. It is used to reference
     a specific hitlocation and can be any integer value. For humanoids it
     is however predefined to be the humanoid body parts. (/sys/wa\_types.h)

     ac can be either an array or a single value. If it is a single value
     than that is the ac for all damage types. (see 'armour')

     The sum of \%hit for all hitlocations should be 100. \%hit is used
     to determine the chance that a specific hit on the object will hit
     a given location. 

     The hitdescription is a string describing the hitlocation. This
     string is sent to the combat message generator in the attacker or
     the attackers weapon.

{\bf One round of fighting  (found in heart\_beat() in /std/combat/cbase.c)}


This is a short description of the combat 'protocol'. Note that this is 
initialized from the heart\_beat in the combat object, not the living object.
This will ensure that combat continues even if the heart\_beat in a living
object for some reason ceases to work.

\begin{itemize}
    \item{\bf 1)} Ensure that we have a valid enemy. This includes checking
           for ghost, linkdeath, run away enemy etc.

    \item{\bf 2)} For each attack that gets done, due to \%use, do:

    \begin{itemize}
        \item  Find out if the attack hits the enemy.
            Two calls are made and must return true:

        \begin{itemize}
            \item cb\_try\_hit(attack\_id)
                 Something inherent to this attack can make
                 it fail. Perhaps a weapon which only works
                 one time out of three.
            \item cb\_tohit(attack\_id, wchit, enemy)
                 This decides if this attack succeeds against
                 a specific enemy. Size, weight, dexterity and
                 other factors can make a difference here.
        \end{itemize}

        \item  Tell the enemy that it was hit by calling: \\
        (**) enemy-\verb+>+hit\_me(wcpen, damtype, myself, attack\_id)
            If the 'to hit' failed above then hit\_me is still called
            but with wcpen == -1, indicating a miss.

         \item With the result returned from the above call, generate
          combat messages by calling:
          
            cb\_did\_hit(attack\_id, hitlocdesc, \%hurt, enemy)

         \item Check on the enemy if it still has hitpoints left by: \\
         (**) enemy-\verb+>+query\_hp() \\
          If the enemy has no hitpoints left then call:
         (**) enemy-\verb+>+do\_die(myself) \\
          and break of the round of attacks.
    \end{itemize}

    \item{\bf 3)} Decrease our fatigue with one. If we are too tired then decrease
       our hit points.

    \item {4)} (**) If the enemy not worth fighting, ie gone or enemy-\verb+>+query\_ghost()
       then swap to another enemy.
\end{itemize}

Note that all cb\_ calls are internal to the combat object.
For specific hooks see 'humanoid\_combat' and  'creature\_combat'

Note the '(**)'. To make an object which it is possible to 'fight', you need
these four functions: 

\begin{itemize}
\item hit\_me(), should return ({  \%hurt, "hitloc description" })
\item query\_hp(), should return 0 if the object is 'dead'
\item do\_die() Do whatever when 'killed'. No return value.
\item query\_ghost() should return 1 if object has been 'killed', but still
      remains for some reason.
\end{itemize}

Note also that the normal 'kill name' will not start combat with a nonliving
object. To initialize combat the object must call:

\begin{itemize} 
\item player-\verb+>+attack\_object(this\_object())
\end{itemize}

This could simply be done in a normal 'add\_action' routine as a result from,
say the command 'bash door'. 


\subsection{creature\_combat}

This file documents the how to make generic nonhumanoid creatures and how the
combat system works for them.

There is basically two different types of creatures:

\begin{itemize}
\item{\bf Tool users} \\
        These are nonhumanoid creatures that still use weapons
        and armours. These tools can be entirely or partially
        incompatible with humanoids. 
    
\item{\bf Non tool users} \\
        These are normally animals that have no concept of tools
        and fight with what they were born with, things like
        fangs, claws and a tough skin.
\end{itemize}

Tool users normally use the combat object: /std/combat/ctool.c
This is the generic version of the humanoid combat object. 

\begin{verbatim}
    *
    * Docs will continue, I reference to the code for now.
    *
    * Some examples can be found in /doc/examples/mobiles
    *
\end{verbatim}

\subsection{drinks}

This file documents the drinking system with respect to amount of liquid
and amount of alcohol.

{\bf Basics}

{\em Drinking}

\begin{itemize}
\item All drinks should inherit '/std/drink'
\end{itemize}

\subsection{experience}

This document describes how people earn xp in 3.0

{\bf Background}

In older versions there were two problems with the xp system:

\begin{itemize}
    \item  It promoted hack'n slash type playing
    \item  It was artificial to 'buy' levels with xp and money.
\end{itemize}

The first problem was more or less solved by introducing quests. These were
seen as an artificial way to make it harder to become wiz. There were no
real motivation to why you had to do quests.

In 3.0 both this problems are dealt with.

{\bf Quest type experience and combat experience}


The total amount of xp gained from combat is stored in the player. When gaining
xp a special flag denotes that the xp is gained through combat. When this flag
is true, the xp gained is REDUCED by a factor equal to combat\_xp/total\_xp
ratio of the player. This is the so called 'brute factor'.

This means that a player who only gains xp from combat will find himself
getting less and less for each fight. To truly learn more and get more
experienced he will have to go questing. 

Note that xp gained from quests are not reduced by the 'brute factor'. Note
also that after some quest xp is gained, it can be rewarding to fight again.

This removes the explicit demand to solve a certain number of quests. 

{\bf Stats instead of levels, learning instead of buying}


The second problem was the artificial system of buying levels. The levelsystem
is replaced by a number of stats in 3.0. These stats reflects the players
experience and matureness in for example: Strength, Wisdom, Disciplin

These stats are not bought, a player can 'meditate' before adventuring and 
thereby telling himself which stats he will concentrate in learning (raising).
When xp is gained the stats are raised reflecting these 'mental settings'.

Note that money has no effect on these stats.

{\bf Presentation of xp}


The player are never given a numeric value for his experience. The player
should have no concept of experience points as such, only a description of
how strong, intelligent, wise etc the player is. The only numerals presented
to the player are the \%-values of the 'mental settings'. These can, after
proper preparation, be set to numbers between 0-100. The sum equal to or less
than 100 of course.

{\bf Using the new xp system}


To add experience to a player simply call: add\_exp(amount, combat\_flag)

If combat\_flag is true the xp will be considered gained in combat and therefore
reduced by the 'brute factor' it will also be added to the total amount of
combat\_xp in the player, which is used to calculate the 'brute factor'.

Quest type experience should not be repeatedly given for doing the same thing
over and over again. Use random changes in your minor quests to make them
nonrepeatable.

For larger quests there is a set of 'quest flags' in the player. The right to
these can be applied for and then used to store information on if a player has
done a certain quest before or not. See 'quest\_bits' and 'make\_wizard'

To get quest bits, talk to your domain lord.


\subsection{file\_dependencies}


\subsection{guilds}

{\bf Types of guilds}


Guilds are built on this idea: A living character has an ethnic back=
ground that he has common with other characters in his neighbourhood.
He has a chosen profession in which he specializes. He also has an
amateuristic interest in which he has some skill. Besides this he is a
member of some local clubs and organizations.

Guilds are divided in to 'major' and 'minor' guilds. Major guilds are
powerful guilds that give considerable advantages to its members.
Minor guilds are very little more than 'secret societies' and 'clubs'
that only add to the feeling of the game or at most provide very
simple features to its members. A player can be a member of as many
minor guilds as he likes.

The major guilds are divided into three types: 'race', 'occupational'
and 'layman'. A player can only be a member of one of each major guild
type. A major guild may have a 'minor' subguild of course.

The race guild is a guild that primarily is intended to give a
background and some racially characteristic traits to its members. It
can be a tribe of dwarves for example that only live in high mountains
and sport braided moustaches (females and males alike). The race guild
should \_not\_ define inherent magic or extranormal abilities and skills
in the player since all races are meant to be alike. In this respect
the race guild can be seen as the least powerful of all guilds, but it
is of the greatest importance as seen from the player's point of view
since it supplies him with a background and a place of origin. A basic
part of the race guild should be a player 'soul' with race=specific
emotes of different kinds. 

The occupational guild is the the more common sort of guild. It gives
the player a profession with skills relating to that profession. It is
here that we find the fighter, the magician, the cleric, the thief etc.

The layman guild is the 'everyman' version of the occupational guild.
A fighter that wants to learn the basics of magic will typically enroll
here. An occupational guild will typically have a layman branch as well
where members of other occupational guilds can become members. Naturally,
the level of skill proficiency in the layman guild is quite lower than
in the occupational guild. This type of guild also covers guilds that
can't conveniently be cathegorized as 'race' or 'occupational'.

{\bf Entering and leaving guilds:}


The guild can choose to accept or deny any player for any reason.
Also, the punishment for leaving a guild can be anything, even death,
AS LONG AS the player is informed of this BEFORE he joins the guild.

The punishment for leaving a major guild should be very strict. It
should be very small, maybe even none, for leaving a minor guild.

{\bf There is one basic rule governing guilds:}


Guilds should cost a certain percentage of all gained xp
in a 'guild tax'. The actual \%tax should depend on the
advantages and benefits gained through the guild. 

There will in time be a list of \%costs for typical guild features. This is
some preliminary limits on costs and benefits:

\begin{itemize}
\item{\bf Minor guilds:} \\
    0\% Simple descriptions and items to separate the player
        from nonguild members. No helping features for combat,
        transportation, healing, etc allowed.

\item{\bf Race guild:}
    \begin{itemize}
    \item{\bf 1\%}  Simple helps such as one or two minor items that gives
        up to 10\% help in combat against minor monsters. Maybe 
        guildspecific armour or weaponry.
        
    \item{\bf 2-5\%} Helping items giving 10-25\% aid in combat, this can be
        weapon, armours. Can also sell members consumable help, 
        such as potions of various kinds.
    \end{itemize}

\item{\bf Layman guild:}
    \begin{itemize}
    \item{\bf 5-10\%} Minor spell magic and other combat improving features.
        Combat aid may be 25-50\%.
    \end{itemize}

\item{\bf Occupational guild:}
    \begin{itemize}
    \item{\bf 10-20\%} Normal spell magic and qualified support in combat. The
        combat efficiency may be doubled, ie 50-100\% combat aid.
    \end{itemize}

\item{\bf Extra costs (possibly making exceptions to the stated rules):} \\
    Inherent telepatic abilities
        like tell, but limited to feelings:  5\% \\
        Actual telepathy: 20\%

    (more to come, maybe, 
     come with suggestions of things you want a pricetag on)
\end{itemize}
        
With \%aid in combat is meant that a given player with the helping features
fight that much better than without help. Having 100\% aid in combat therefore
means that the fighting capability is doubled, it does not mean that monsters
fall dead instantly.

{\bf Implementation}

Basically guilds are solved with autoloading shadows. Shadows are pieces
of code that are added to the object in runtime and overloads the original
objects functions. So if a shadow defines 'query\_title' and it shadows
a player, then when 'query\_title' is called in the player, it gets called
in the shadow instead. There is a number of functions that a shadow can
not define, these are the functions defined 'nomask' in the object that is
to be shadowed. Functions like 'query\_wiz\_level' for example :)

There is a small guild example in ~commander/open/guild.c and
~commander/open/guildbook.c (One clones the book and it defines a join cmd)

The example only defines 'query\_title' but you get the idea \ldots :)

To implement the 'tax', you must shadow the 'add\_exp' function.

{\bf Skills}

The number and types of skills available in a guild is naturally dependant
on the type guild of guild. A guild ought to be clearly defined and only
cover ONE field of interest, not several. So for example a fighter-cleric
guild will \_never\_ be accepted under any circumstances.

An minor guild should not offer any skills at all. They are simply not
intended to provide anything more than a bit of feeling in the game.

As for the major guilds, the limits should be set like this:

Any major guild can offer education of up to 700\% of skills. This simply
means that if the guild offers weapon education up to 40\% in five different
types of weaponsm climbing up to 100\% and all appraising skills (3) up to
80\% adding up to a total of: 
\begin{verbatim}
                     40 * 5 + 100 + 80 * 3 = 540 %
\end{verbatim}
The guild can now choose to offer another 160\% in other skills as well.

\begin{itemize}
\item{\bf Race guilds: } \\
    Specialized skills could be considered if they are in the line of 
    the game. Take for example 'minecraft' for dwarves. However, think
    carefully in advance before defining a skill that maybe never will
    be used. The race guild should rather make a selection from the
    ordinary list (see the 'skills' chapter) and exclude weapons and 
    skills that their race never would bother with.

    The maximum teaching level any of those skills are 100\%.

\item{\bf Occupational guilds:} \\
    Again, do use some afterthought before introducing specialized skills
    that no-one but you will ever use. Remember to choose skills from
    the basic list that reflect solely on the occupation. If you are
    found offering magic skills in a thief guild, you're in trouble!

    The maximum teaching level any skill in an occupational guild
    is 100\%.   

\item{\bf Layman guilds:} \\
    The same rules apply to the layman guild as to the corresponding
    occupational guild. However, the maximum teaching level of the
\end{itemize}

\subsection{healing}

Healing can be differentiated into three categories. If you manage 
to think of something that doesn't immediately fit into any of these
categories, put it in "Magic healing by objects".

{\bf Liquor}


These objects should be created by inheriting or cloning the standard
object "/std/liquor.c". The standard value of this object in copper 
coins is calculated with the formula: 

    $cc = 10 + (alco * alco / 10)$
    
Where 'alco' is the amount of intoxication the object heals. This value
is automatically given to the object unless a higher value is specified.

The object may not have a higher 'alco' value than 50. 

A domain may produce a maximum of 1000 hp of healing per reset and
wizard in that domain. No player should be allowed to buy more than
a total 500 hp healing per reset.

{\bf Magic healing by objects (potions, talismans etc)}


A domain may produce a maximum of 100 hp of healing per reset and
wizard in that domain. This kind of magic should be relatively hard to
obtain and not for sale in just any shop. Typically such objects could
be rewards in quests, or maybe just available to members of certain
guild. The healing objects should have a minimum value of 

    $cc = 5 * hp + (hp ^ 2) / 4$

Where 'hp' is the number of hitpoints the object heals.

{\bf Magic healing by spells}


The conversion cost of spellpower should be 1 hp = 2 sp. Also, a 
material component equal to the number of hitpoints healed * 20 cc
should be consumed in the process.


\subsection{humanoid\_combat}

This file documents the humanoid specific parts of the combat system. For
the description of the generic combat system, read 'combat'. You are
recommended to read 'combat' before reading this file.

Humanoid combat is an example of combat that is tool enhanced. Being
'humanoid' also means that you get a set of default attacks and hitlocations.
These are defined in /sys/wa\_types.h

    Attacks: \\
        right fist, left fist, joined hands, left foot, right knee

    Hit locations: \\
        head, left arm, right arm, body, legs

There is two different combat objects that is used for humanoid combat:

    /std/combat/humanoid.c \\
        This is the 'open' object. With this new attacks and hit-
        locations can be added.

    /std/combat/chumlock.c \\
        This is the 'closed' object. No new attacks or hitlocations
        can be added.

Both these objects inherits the generic 'tool' combat object,
 /std/combat/ctool.c which is described below:

\begin{itemize}
    \item  ctool inherits cbase and therefore work more or less like it,
      see 'combat' for description of cbase. It is however extended
      with the concept of combat tools. 
\end{itemize}

\begin{verbatim}
    *
    * Docs will continue, I reference to the code for now.
    *
\end{verbatim}


\subsection{light}

The light system in 3.0 is implemented in LPC.

All objects have a light property: OBJ\_I\_LIGHT. When queried for
the property returns the lightvalue of the object.
    
Lightvalues:
\begin{itemize}
\item{\bf 0} No light given by object
\item{\bf \verb+>+0} Light is generated by the object
\item{\bf \verb+<+0} Darkness is generated by the object.
\end{itemize}

The light in a room is simply all the lightvalues of the objects
added together plus the lightvalue of the room itself. If the room
is linked to a container then the lightvalue of the room in which
that container resides will be added to the lightvalue of the room.

{\bf NOTE}
    
  When you need to set light for an object, container or room it is
  IMPORTANT to use the right property. For example, if you set the
  OBJ\_I\_LIGHT property in rooms or containers then you invalidate
  the light distribution inside them. This means among other things
  that rooms stay dark even if you have a lightsource.

{\bf Setting light value}


\begin{verbatim}
    Objects:    add\_prop(OBJ\_I\_LIGHT, lightvalue)

    Containers: add\_prop(CONT\_I\_LIGHT, lightvalue)

    Rooms:      add\_prop(ROOM\_I\_LIGHT, lightvalue)
\end{verbatim}  

{\bf Lightdistribution in containers}


Containers are special. The lightvalue returned by a container can
depend on the objects inside it. The lightvalue of the container
itself is given by the property CONT\_I\_LIGHT.

OBJ\_I\_LIGHT for a container will be the same as CONT\_I\_LIGHT unless the
container has the property CONT\_I\_TRANSP (transparency) in which case
OBJ\_I\_LIGHT will be CONT\_I\_LIGHT plus all the lightvalues of the objects
inside the container summed.

A special form of container is a container which is linked to a room.
Such a container can not hold objects itself. It's inside is a room
and if the container is CONT\_I\_TRANSP then the lightvalue of the
container would be the lightvalue of the room plus its own CONT\_I\_LIGHT.

\subsection{make\_wizard}

This file describes the general philosophy behind wizardhood, how to
become wizard and why you have to play the game before you are allowed
to add new things to it yourself.

Wizards are people familiar with the mud, who are allowed to add new
things to it. To become a wizard is to be given the right to code.

To become familiar with the mud, players must visit and adventure in most 
of its parts. Only when this is accomplished is the user behind the player
deemed capable of adding new things that will fit nicely in in the game.

LPmud has traditionally been a combat oriented game. To become wizard a
player has had to do repetetive and often boring tasks, like killing the
same monster over and over again. Even for those that have found this to
be an enjoyable type of playing, it has had one major practical drawback.
Players have usually concentrated on playing in a very small part of the mud
and many have become wizard without really having seen more than that
small part. 

The sole purpose of making it an effort to become wizard is therefore to
ensure quality in new parts of the game. There is no purpose in making it
hard to become wizard just because it is supposed to be hard or supposed
to take a lot of time. We all play and code in LPmud to have fun, useless
hard work is something most of us expect to get paid in cash for.

The wizards are specifically not an elite club of people that is to snort
at the mere mortals and directly interfere with there playing. Any wizard
found doing that is firstly warned and then expelled from the mud. The idea
is for everyone to have fun, not for some to have fun on others behalf. 
Wizards are there to serve the mortals in making a better game, nothing else.

So, how is this accomplished? 
What has changed since earlier versions of the mudlib?

The key to the new system is the changed experience point system. This is
documented in 'experience' and what it basically does is to divide xp in
normal xp and combat xp. Combat xp are special in that:

\begin{itemize}
\item{\bf 1)} It is the only xp lost when a player dies.
\item{\bf 2)} The bigger ratio combat/normal xp the less xp actually gained when
   killing a monster, ie getting more combat xp.
\end{itemize}

The old quest system with an obligatory number of quests is removed, instead
there is the 'normal xp'. Normal xp are given to players upon exploring and
solving quests. Normal xp is special in that:

\begin{itemize}
\item{\bf 1)} Once gained they can never be lost.
\item{\bf 2)} They can never be gained twice for doing the same thing.
\end{itemize}

To support the second point, each domain get 100 bits in each player. These 
bits are supposed to be used for marking of what a certain player has
already been given normal xp for. The bits are documented in 'quest\_bits'.

Some immidiate consequences of this:

\begin{itemize}
\item{\bf 1)} It is no longer possible to make xp-pumps. If almost all xp a player has
   is combat xp, then it is almost impossible to get more combat xp.

\item{\bf 2)} Gathering great weapons and armours are of a lot less importance.

\item{\bf 3)} It is rarely usefull to kill monsters for the sole purpose of killing. If
   a player have to fight there is a reason to fight.

\item{\bf 4)} The significance of death diminishes. However as combat xp do count as
   xp, something is lost. Also losing all belongings is often a major setback.

\item{\bf 5)} Lessening the importance of combat makes nonfighter classes more
   attractive. This is also encouraged by the new team possibility. See
   docs on 'teams'.

\item{\bf 6)} Making an attractive area forces wizards to write systems of minor and
   major quests. This will hopefully cause a better and more interesting game.
\end{itemize}

Quests can be as simple as solving a riddle or finding something in a hidden
compartment, it can be as complex as gathering lots of tools and gadgets to
accomplish a major task. The amount of xp should reflect the complexity
and the amount of time a player would have to spend to solve the quest.

To become wizard, a player must solve a final quest for immortality.
This quest will demand that the average stat's of the player is more than
a certain value. The chance of solving this final quest will be dependant
on the average stats.

Players are graded by their stats. There is six basic stats and three guild
specific stats. A stat is a number between 0-150. To have any chance at all
of solving the 'immortal quest' a player must have an average of 90. If the
player has an average of 100, success is ensured.

A scale for normal xp is given in 'xp\_scale'. This gives some guidelines
as to how much xp to give for different tasks. 



\subsection{meet\_people}

DO NOT CHANGE THIS FILE! IT HAS ALREADY BEEN INCORPORATED IN THE GLOBAL
DOCUMENTATION. CHANGE LPmud.texinfo INSTEAD.

This document describes how people learn each others names in 3.0. This is
basically a social function of the game but it adds to the realism too.

{\bf Background}

In earlier versions of LPmud, the names of all players were known to all other
players. This gave an indication as to if a character met in the game were
actually a player or just an NPC. NPC's could of course mask themselves as
players by giving themselves a name, it was still not very good. Why would I
know all these names? Where all the characters in the game wearing nametags
or what?

In 3.0 the concept of races is introduced for the players. In earlier versions
race has only been an NPC attribute. All players have been human, if anything.
The race of a character is assumed directly visible, this might not be true
in every concievable case, it is a simplification, although a much better one 
than that everyones name is always known.

If however I meet a character, and we exchange names, we have been introduced.
When I meet him next time I will most likely recognise him and therefor I will
know his name. 

{\bf Characters met, introduced and remembered}

Too keep track of which players should be introduced by name and which should
be introduced by race all players must hold lists of who they have been
introduced too. These lists must somehow be limited to save memory. This is
how it is stored in 3.0:

\begin{itemize}
    \item  There is one list of people who have introduced themselves to you.
    \item  There is one list of people who you have chosen to remember.
\end{itemize}

The maximum size of both lists depend on your 'INT' stat. When you log out
only the 'remember'-list is saved. Wizards do not have such lists, they always
know the name of all players. 

When you meet a character you can introduce yourself and be stored in that
characters 'introduce'-list. Only if he chooses to remember you and gives the
command: "remember \verb+<+yourname\verb+>+", will you be stored in his 'remember'-list.

{\bf Consequences for say and tell\_room}


As these functions are used to tell something to a group of players, they are
gravely affected by the fact that the message will be dependant on the
reciever. As an example: "Lars takes two apples from the box.", this message
is dependant upon if I know Lars or not. In a room with five people, two of
them should maybe have: "The human takes two apples from the box.", instead.

The simple solution is of course not to use say and tell\_room, but instead tell
each player separately the correct message. Say and tell\_room has however been
changed to support these kind of reciever dependant messages.

There is in fact two ways of solving the problem and both is implemented:

\begin{itemize}
    \item  Send two alternative messages to say/tell\_room
    \item  Use the concept of 'value by function call'.
\end{itemize}

The first is the fastest, although it will not solve all concievable cases.
The second is somewhat complex and timeconsuming, it will however always work.

To use the first alternative you simply do:

\begin{verbatim}
    say( ({ "Message including name", "Message not including name" }) );
\end{verbatim}

In some cases this will not work, example: "Fatty gives two apples to Lars."
To solve this the second alternative must be used. In this the message is sent
to each reciever by a call to 'catch\_msg'. This function replaces any
occurences of a 'value by function call' description in the string with the
returned value.

For the first example above you would do:

\begin{verbatim}
    say( "@@query_name takes two apples from the box." );
\end{verbatim}

The second would be a little tougher:

\begin{verbatim}
    say( "@@query_name:" + file_name(fatty_player) + " gives two apples " +
         " to @@query_name:" + file_name(lars_player));
\end{verbatim}

    Where fatty\_player and lars\_player are two variables you have defined
    holding object pointers to these player objects.

This gets complicated and to simplify things a set of macros is defined in
"/sys/macros.h". The above example would be:

\begin{verbatim}
  say( QCTNAME(fatty_player) + " gives two apples to " + QTNAME(lars_player));
\end{verbatim}

These are the most usefull macros:

\begin{verbatim}
    #define QMET(func, ob) "@@"+func+":"+file_name(ob)+"@@"
    #define QSHORT(ob) QMET("short", ob)
    #define QNAME(ob) QMET("query_art_name",ob)

    /*
     * QCNAME is the same as QNAME except that it returns a capital A or An
     */
    #define QCNAME(ob) QMET("query_Art_name",ob)
    /*
     * QTNAME is the same as QNAME except that it returns 'the'
     */
    #define QTNAME(ob) QMET("query_the_name",ob)
    /*
     * QCTNAME is the same as QTNAME except that it returns a capital 'The'
     */
    #define QCTNAME(ob) QMET("query_The_name",ob)
\end{verbatim}

To use the above macros you must do:

\begin{verbatim}
    #include "/sys/macros.h"
\end{verbatim}

For details of how 'value by function call' works, look at the function 
'check\_call' in /std/object. 

For more extensions to the efuns say and tell\_room see 
/doc/efun/say and /doc/efun/tell\_room



\subsection{money}

You may create your own money by simply inheriting or cloning the
object "/std/coins.c". This object can then be modified to give the
description you would like. If you have a room or an object that
handles money, like a shop for instance, and you would like to handle
mixed denominations you should include the file "/sys/money.h". This
file contains routines for converting CP to a set of mixed
denominations and vice versa.

{\bf Copper Coin (cc)}


This is the smallest denomination available and equals about one krona
in value (\$1 = ca 6 kr for conversion purposes). All values stored in
objects are given in cc. The cc weighs 18 grams and is 2 cm\verb+^+3 in
volume.

{\bf Silver Coin (sc)}


An sc is worth 12 cc. The sc weighs 21 grams and is 2 cm\verb+^+3 in volume.

{\bf Gold Coin (gc)}


A gc is worth 12 sc. The gc weighs 19 grams and is 1 cm\verb+^+3 in volume.

{\bf Platinum Coin (pc)}


A pc is worth 12 gc. The pc weighs 21 grams and is 1 cm\verb+^+3 in volume.

{\bf General management of coins (heap objects)}

Coins are an example of 'heaps'. This is a special form of object that
represents a countable amount of separate objects. It means that no matter
how many identical coins you have you still carry only one object.

You have one object for each type of coins. That is if you have: 4 gc, 13sc
and 123 cc, you carry three objects, one for each type of coins.

The lfun move() is adapted to handle heaps. This means that move() sees to
it that heaps are joined appropriately.

When a part of a heap is to be moved a special lfun is first called in the
heap object: 

\begin{verbatim}
    heap_ob->split_heap(int amount)
    heap_ob->move(new_dest);
\end{verbatim}

This moves 'amount' pieces of the heap to the new destination.

To create a new heap of a certain size you do:

\begin{verbatim}
    heap_ob = clone_object(heap_file);  /* could be /std/coins */
    heap_ob->set_heap_size(100);
    heap_ob->move(new_dest);
\end{verbatim}

This creates a new heap of size 100 and moves it to some destination.

In /std/coins.c there is a function for setting the type called: set\_coin\_type

To simplify this for coins there is four macros in /sys/money.h that
returns an object which is the right type and amount of coins.

\begin{verbatim}
MONEY_MAKE_CC(num)      /* Returns a heap object of 'num' copper coins */
MONEY_MAKE_SC(num)      /* Returns a heap object of 'num' silver coins */
MONEY_MAKE_GC(num)      /* Returns a heap object of 'num' gold coins */
MONEY_MAKE_PC(num)      /* Returns a heap object of 'num' platinum coins */
\end{verbatim}

There are a number of other useful routines in /sys/global/money.c which
are documented there and can be used either through macros in /sys/money.h
or as direct calls using the filename, ie MONEY\_FN-\verb+>+func\_call(params);

Among others are routines for moving coins in a simple fashion.



\subsection{monster}

This file documents some specific details about making monsters. 

{\bf Description}

Monsters are essentially NPC's. This means that they have almost all the
qualities of a normal player including a lot of commands such as
emotions and object manipulation. They are also included among creatures
that players can be introduced to.

This means that monsters are different from ordinary object with respect
to their shortdescription. 

You can directly set the short of a monster, BUT if you do so the player
emulation of the short and long will dissapear.

Player emulating monsters are identified by three things:

\begin{itemize}
    \item  Their actual name (Some monsters might not have a name)
    \item  Their race name
    \item  Any number of adjectives
\end{itemize}

Normally a player have not been introduced to a monster and the short() will
therefore be: 'adj adj adj race\_name'

To ensure that a monster is never introduced you can add a special property,
(see properties/living), called LIVE\_I\_NEVERKNOWN

This is especially usefull for animals which really has no specific name.

{\bf Unarmed combat}

Check out the examples in /doc/examples/mobiles

{\bf Reward for kill}

When a player kills a monster, the player is rewarded with a certain amount
of combat experience. (see experience) This is in fact true also if a monster
kills another monster.

The formula for reward exist in /std/combat/cbase::cb\_reward and is:
\begin{verbatim}
    3 * averagestat * averagestat * %reward
\end{verbatim}
averagestat is simply
\begin{verbatim}
(str + con + dex + int + wis + dis) / 6
\end{verbatim}
\%reward is a percent modifier (50-150) that can be set for a monster
to indicate how much more or less rewartding it is than an average monster
of the same stats.

A monster with more than usual skills is more diffult for example and should
be more rewarding.

A monster with valuables should be less rewarding as the player gets other
rewards than xp too.

If you want your monster to have weapons and/or armours you should normally not
let it have higher hit, pen or ac than the average of your monsters stats.
    

\subsection{quest\_bits}

As you might remember, there was a system in the old Genesis where you
could request and receive a limited number of quest-flags in a player.
These flags were then stored in the player and you could easily keep
track of a player's progress in one your quests. The trouble was that
the total amount of bits was limited, in reality you could at most
get around 10 bits in a player. I've introduced a system here that 
is centered around the domains. Every domain has automatically 100
bits available in a player for quest (and suchlike bookkeeping) use.

The bits are grouped into five groups of 20 bits. It's up to you to
decide what you want to use them for. Any domain object (or player)
has the power to affect these bits in a player, so I advice you to 
keep careful notes of what bits you use for what purpose. The command
"bit" will allow you to examine a logged-in player and affect the 100
bits that your domain has available in him. The lfuns are best studied
using the command in wiz\_cmd\_apprentice.c as an example.

N.B. Do NOT use a bit unless you are really really certain that you want
to use it for a specific purpose. Remember that once used, it's almost
impossible to change the use of a bit since it might be set in a number of
unknown players (no way to erase a certain bit in every player).

So, use them, but also use a bit of afterthought before becoming too
enthusiastic. The bits are not stored unless set in a player. This means
that as soon as you set 1 bit we have to store a group of 20 bits in a
player.

Some hints as to effective use of the bits:

\begin{itemize}
\item  If you have a complex quest which is solved in stages, you do better
  by reserving say 4 bits and use them as a number 0-15 for fifteen stages
  in the quest, intead of using fifteen separate bits.

\item  If you have used 1 bit in a group, it does not take more space to use the
  other 19 bits, as these are represented as a single number in the players
  save file. This means that you should use up one group of bits before
  starting with the next.
\end{itemize}

Actual usage in your code: (see also /std/player/savevars\_sec.c)

    {\em player-\verb+>+set\_bit(int group, int bit)} \\
    This sets a given bit in a given group. The euid of the object
    calling is used to decide what domain is relevant. 

    {\em player-\verb+>+clear\_bit(int group, int bit)} \\
    This clears a given bit in a given group. The euid of the object
    calling is used to decide what domain is relevant. 

    {\em player-\verb+>+test\_bit(string domain, int group, int bit)}
    This tests a given bit in a given group. The euid of the object
    calling is used to decide what domain is relevant. 


\subsection{skill\_list}


Skillnumber allocation:

\begin{verbatim}
0000 - 0499 Standard skills

0500 - 0999 World specific skills. These are skill that are specific to
            one LPmud world. 

1000 - 4999 Reserved for future use.

5000 -      Free skill numbers. You can use them but have no guarantee
            that somebody else does not use them for something else.
\end{verbatim}

{\bf NOTE:}
    Normal range of values are 0-100. Where 0 is no special ability 
    and 100 is extremely good.

\begin{verbatim}
Skillname       ##          Description

/* Weapon skills */
#define SS_WEP_SWORD        Sword fighting skill
#define SS_WEP_POLEARM      Polearms
#define SS_WEP_AXE          Axes
#define SS_WEP_KNIFE        Knives
#define SS_WEP_CLUB         Clubs; any blunt weapons really
#define SS_WEP_MISSILE      Missiles; rocks, arrows...
#define SS_WEP_JAVELIN      Javelins, thrown spears...

/* Specialized fighting skills */
#define SS_2H_COMBAT        Two handed combat
#define SS_UNARM_COMBAT     Unarmed combat
#define SS_BLIND_COMBAT     Fighting while blinded
#define SS_PARRY            Parrying with weapons
#define SS_DEFENCE          General defensive skill

/* Magic skills */
#define SS_SPELLCRAFT       General spellcasting ability
#define SS_SPELL_ATTACK     Attack spells
#define SS_SPELL_DEFENCE    Defensive spells
#define SS_SPELL_HEALING    Healing spells
#define SS_SPELL_ILLUSION   Illusions
#define SS_SPELL_MISC       Any other spells
#define SS_HERBALISM        Know herbs & plants from spellcasting value
#define SS_ALCHEMY          Mix stuff together. Potions and stuff.

/* Thief skills */
#define SS_OPEN_LOCK        Pick locks.
#define SS_PICK_POCKET      Pick pockets.
#define SS_ACROBAT          Doing strange stuff on high places.
#define SS_FR_TRAP          Find/Remove traps without coming to harm.
#define SS_SNEAK            Sneak into rooms.
#define SS_HIDE             Hide in rooms.
#define SS_BACKSTAB         Do something bad to someones back.

/* General skills */
#define SS_APPR_MON         Appraise an opponent.
#define SS_APPR_OBJ         Find out properties of objects.
#define SS_APPR_VAL         Value an object.
#define SS_SWIM             Swim.
#define SS_CLIMB            Climb.
#define SS_ANI_HANDL        Handle animals.
#define SS_LOC_SENSE        Know where you are.
#define SS_TRACKING         Track something in the wild.
#define SS_HUNTING          Hunt for your living.
#define SS_LANGUAGE         Speak other languages.
#define SS_AWARENESS        Be wary of sneak/hide/backstab.
#define SS_TRADING          Trade with profit
\end{verbatim}


\subsection{skills}

This document describes how skills work in CDlib

{\bf Background}


Skills are all the pieces of knowledge of different things that a mortal may
gather to manage a long journey through a dangerous life.
    
Skills defer from stats in that they are not gained through experience, ie
indirectly. Skills are usually bought with money, as training courses, or
gained as rewards after solving a quest. Some races may also be born with
certain skills or have a special talent to learn them.

There is in theory no limit to the number of different skills in the game.
However, as all objects in the game should interpret skills in a similar
way there must be a standard. Therefore most skills must be registred in
a central place in the game.

It is entirely up to you, the coding wizard, to see to that you check the
relevant player skill in a situation where it is logical that he uses it.
Some skills, like weapon and defence skills, are used by the game during
fighting for example. However, the majority of the skills and situations
where skills are used have been left to you to take care of.

{\bf Functionality and implementation}


A skill is simply a pair of two numbers. The skill number and the value.
It is implemented as two lists in all living objects. 

All nonexistant skills are considered to have the value 0.

There are three routines for managing skills:

\begin{verbatim}
    set_skill(int skill_type, skill_value)
    query_skill(int skill_type)
    query_skill_cost(int old_skillvalue, new_skillvalue)
\end{verbatim}

The first two are merely for setting and querying the skill values. The third
is a standardized cost function that returns what the relative cost for 
raising between two skill values should be.

{\bf Guilds \& skill availability}


The file 'skill\_list' defines all available skills and gives a brief
description of their use. A more detailed description will be added later.

Most of the skills from the basic skill list are only partially available
to all players. To gain proficiency in the more specialized skills he will
have to join a guild. The file 'guilds' has a special chapter about this.

The skills listed below here could be available in any guild up to the 
stated level. 

\begin{verbatim}
Generally available skill   max level
-------------------------   ---------
SS_WEP_SWORD                    30
SS_WEP_POLEARM                  30
SS_WEP_AXE                      30
SS_WEP_KNIFE                    30
SS_WEP_CLUB                     30
SS_WEP_MISSILE                  30
SS_WEP_JAVELIN                  30
SS_SPELLCRAFT                   20
SS_APPR_MON                     50
SS_APPR_OBJ                     50          
SS_APPR_VAL                     50
SS_SWIM                         50
SS_CLIMB                        50
SS_ANI_HANDL                    50
SS_LOC_SENSE                    50
SS_TRACKING                     50
SS_HUNTING                      50
SS_LANGUAGE                     50
SS_AWARENESS                    50
SS_TRADING                      50
\end{verbatim}

For other skills, or for higher levels, the player will have to enter the
appropriate guild.


\subsection{souls}

This document describes how to write a command soul.

{\bf Definition of command soul}

A command soul is an object that isn't loaded directly into a player,
but is linked to him in order to give him an extended set of commands.
The commands aren't added using add\_action but instead the command
parsing is done inside the souls themselves. The intention of using a
soul is to have an easily changeable command-defining object for more
than one person to use. 

There are two types of command souls; ordinary "souls" and tool souls.
The ordinary soul will define commands that needs no special priviliges 
while the tool souls gain the rights of the user before executing a 
command. There is no difference in the souls as such however, the user
need only to know how to add the soul to his set of souls, if to add it
as a tool soul or as an ordinary command soul.

{\bf How to write a soul}

The soul may not contain any global variables because of the way it 
functions. The same soul is used by all players. If you HAVE to have
a global variable you can set a property in the player for that use, 
but please try to avoid doing that.

The soul must inherit "/cmd/std/command\_driver" in order to work. This
file contains the function for identifying and executing the given
command. You might also want to inherit "/std/simul\_efun" to get
access to some very common commands.

The soul must contain the following functions:

string get\_soul\_id() \\
mapping query\_cmdlist()

The function get\_soul\_id() should return the lowercase name of the
soul. Try to keep the name short and to the point since it is used in
the command "allcmd".

The function query\_cmdlist() should return a mapping containing the names
and functions of the commands. 

The function query\_tool\_soul() or query\_cmd\_soul() must be defined
and return 1 when called for the approprite type of soul.

The rest of the soul file should simply be the functions you want to
define. These functions must return 1 when a command has been executed
in any way (successfully or not) or 0 if it proved that the command
given was not intended for this soul. For example, if you have a
command "shake" that expects the argument "hands with xxx" in order to
allow someone to shake hands with someone. If the first argument is
anything else than "hands" the function should return 0 since the
player probably meant "shake my head in disagreement". However, if the
player "xxx" wasn't present and you wrote a message to that effect you
should return 1 since the command was intended to be the one you
defined.

A nice way to generate fail messages in the event that the command
indeed was the only one defined with that command verb is to use
"notify\_fail()".

Here is a short example of the previously discussed command soul.

\begin{verbatim}
/* Example of command soul */

inherit "/cmd/std/command_driver";
inherit "/std/simul_efun";

string
get_soul_id()
{
    return "mycommands";
}

int
query_cmd_soul()
{
    return 1;
}

mapping
query_verbs()
{
    return ([ "shake":"shake_hands", "hi":"hello" ]);
}

int
shake_hands(string arg)
{
    string *argv;
    object shakee;
    
    if (!strlen(arg))
    {
    notify_fail("Shake hands with whom?\n");
    return 0;
    }
    
    argv = explode(arg, " ");

    if (argv[0] != "hands")
    {
    notify_fail("Shake what?\n");
    return 0;
    }

    if (sizeof(argv) != 3 || argv[1] != "with")
    {
    notify_fail("Sorry, I don't understand what you want to shake.\n");
    return 0;
    }

    if (!(shakee = present(argv[2])) && living(shakee))
    {
    write("Sorry, no " + argv[2] + " here to shake hands with.\n");
    return 1;
    }

    say(QCTNAME(this_interactive()) + " shakes hands with " + QTNAME(shakee)
        + ".\n", ({ this_interactive(), shakee }));
    
    shakee->catch_msg(QCTNAME(this_interactive()) + " shakes your hand.\n");
    write("You shake hands with " + QTNAME(shakee) + ".\n");
    return 1;
}

int 
hello()
{
    say(QCTNAME(this_interactive()) + " says hi.\n", this_interactive());
    write("You say hi.\n");
    return 1;
}

/* End of example */
\end{verbatim}

For other examples on command souls see /cmd/std/misc\_soul.c and
/cmd/std/soul\_cmd.c. For example on a tool soul see /cmd/std/tracer\_tool.c



\subsection{spells}

Magic is a very difficult concept to define. A lot has to left to the
good judgement of the domainlords. The best is naturally to check with
an archwizard if the intended magic falls beyond the listed categories
before implementing something of dubious quality. Note that the supplied
method of implementation of personal magic isn't a recommendation, it is
a requirement.

{\bf Object magic (potions, scrolls, talismans etc)}

With this is meant magic that is found on as objects that you activate
with an action or a word of some kind. This kind of magic doesn't
normally require spell-points from the caster to work, but should be
treated as incidental magic with the object being consumed after
completion. This kind of magic should ordinarily work independant of
the user's magic skill or related stats.

Object magic should typically be found as rewards in quests and not
just lying around or being carried by guarding monster. It might be
sold as potions or scrolls in specialized guilds but definately not in
ordinary shops. Remember though, that anything found in a shop should
be of lesser quality than what can be found by adventuring.

{\bf Personal magic ("spells")}

This is what is normally thought of as "spells". It's some kind of
repetitive magic that can be called upon by the player simply by
speaking a special word or performing a special action. The success of
this magic should be dependant of the player's magic skill and perhaps
also of the related stats (intelligence, wisdom and disciplin). To
perform this magic the player should have to pay with mana and also
with some sort of material components. These components should have a
value and have to obtained as objects somewhere. Magic that only
require spellpoints should be rare and comparatively powerless. The
more powerful the magic, the more rare and expensive material
components.

Personal magic should only be available to people who has devoted
themselves to studies in the field. This means that no ordinary player
will have access to this type of magic. He would typically have to be
a member of a guild that supplies this type of magic. He would have
to learn the skills at a cost there and then gain access to better and
better spells as he advances his rank within that guild.

{\bf Implementation, game support}

The implementation of object magic can be very straight-forward. Just
implement the gadget as you would any other object. Use add\_action to
define the activating action or word.

Personal magic on the other hand should be taken care of in a
different way. In order for this type of magic to be taken care of
properly by the player you MUST do as follows:

The spell object, the object that holds the spells, must inherit the
file /std/spells.c in order to work. In that object you can find a
description telling you which functions to call and for what reason.

You must also make a file in the directory /open/SPELLS with the
spell-verb of you spell where you describe the spell and list the name
of the object that defines it. If there already exists a spell with
that name, you must either use that spell or have a very good reason
for creating a new with the same name. There is sufficient that there
is one "fireball", one "magic missile" etc in the game. All spells
should be unique, no duplicates please. Please don't just invent a new
name for the same spell in order to be able to add it. We won't like that.
Use the same spell but with the new name instead and make your file
contain information to that effect.

The player will at all times be able to type "spells" and get a list
of the spells he has active, providing that you have followed the
instructions above. 

{\bf Game skills}


See the 'skills' file in this directory.

{\bf Resistance properties}


There are a number of resistance properties that deal exclusively with
magic. These properties all work in the same way, by defining a
resistance in the living object by using an external object that
defines the actual resistance. This can be items like rings, cloaks,
braces or even potions and spells. It works like this: The property
that is stored in the living object contains a count of the number of
objects in the inventory that defines a resistance. When the
resistance object is removed it should decrement the count in the
living object it protects. A spell should simply add an object with no
short or long that defines this property in the player with a call\_out
of suitable length before it self-destructs.  The object resistance
property should be an array with two values defined: ({ resistance,
additivity }). The resistance is simply a percentage, if it was
defined to 25 and 8 hp was inflicted, only 6 hp would actually be
taken. The second value is 1 or 0 depending on wether the resistance
is additive or not. If it is additive, it will be added to other
additive resistances in objects the player is carried, if not it will
be counted separately. So, if the player wears one object with a
non-additive resistance of 30\% and four other that are additive and
come up to 24\%, he still will have a 30\% protection. The maximum of
the two would be used in any occation.

The algorithm for obtaining the sum of the resistances in a living
object is a bit complicated. It's not just a simple addition since
that would make for too radical protection changes by just adding a
few objects. The algorithm works like this:

If you have n objects that provide protection:

\begin{verbatim}
Protection = (1 - MUL(1 -> n)[1 - objres(n)]) * 100 %
\end{verbatim}

For example, if you have a 30%, a 20% and a 45% additive resistance
object on you, the result would be
\begin{verbatim}
(1 - (1-0.3)*(1-0.2)*(1-0.45)) * 100 = 69%
\end{verbatim}
in total protection. Not 95\% as would have been the case
with simple addition.

There are custom routines in the living object for returning the
actually made damage, given the resistance property and the damage you
intended to make: Just call the function \\ query\_res\_damage(RES\_PROP,
damage); to get the actual damage that you inflict.

The maximum resistance in an addtivie resistance object is 40\%. The
maximum resistance in a non-additive resistance object is 75\%. You may
not make any object better than this. Also, objects with so high
resistance should be very hard to obtain.

{\bf Distinctions of power}


An important question is naturally how to order personal magic in
"cost". Which magic should be available to whom and so on. A very
natural rule-of-thumb is that players who are members in magic-related
guilds have access to magic that others never will see. You must also
distinguish carefully between which magic is available to which guild.
For obvious reasons a figher guild should only have very minor access
to healing magic. It's simply not their business to heal people, they
use offensive magic, but again not very powerful magic. A figher guild
fights with weapons, not magic. A priest guild might have access to
powerful healing spells, but not very powerful offensive spells. A
wizard guild has offensive \& defensive magic, but no healing magic and
so on. Use common sense when setting up the spellists and you will
have no trouble. Ignore common sense and rules, and you'll find
yourself outside the game as soon as it is discovered.

The text following here is a very temporary thing. It will probably 
have to be replaced by something more detailed later, but you can use
it as a guideline when you design your spells. 

Let's measure the proficiency of a player in the game or in a guild
in 10 levels. A level 10 player in the game is just about to become
wizard, a level 1 player has just started.

The player is a member of a non-magical guild, or no guild at all:

\begin{verbatim}
Lvl 1 -  3: No magic. He simply won't get access to it other than
            as object magic, never as spells.
    4 -  6: Very minor spells.
    7 - 10: Minor spells.
\end{verbatim}

The player is a member of a magic-related "other" guild. In other words
magic is not his major subject, he's just studying it on the side:

\begin{verbatim}
Lvl 1 -  3: Very minor spells.
    4 -  6: Minor spells.
    7 - 10: Intermediary spells.
\end{verbatim}

The player is a member of an "occupational" guild specializing in magic.

\begin{verbatim}
Lvl 1 -  3: Minor spells.
    3 -  6: Intermediary spells.
    7 - 10: Advanced spells.
\end{verbatim}

\begin{itemize}
\item{\bf Very minor spells:} Typically spells that harms no one, only gives
            limited information and help. Examples of this
            kind of magic is temporary light and darkness
            spells, limited information detection spells.

\item{\bf Minor spells:} Very minor healing/damage, easy detection spells,
            minor defensive, dispelling spells.

\item{\bf Intermediary spells:} Ordinary healing/damage, detection, defense,
            dispelling etc.

\item{\bf Advanced spells:} Advanced detection spells (see stuff in other rooms,
            know other people's inventories etc). Powerful
            attack/healing spells. Advanced dispelling, maybe
            even stat-affecting spells. Limited conjuring power
            for very advanced players.
\end{itemize}


\subsection{starting\_locations}

Until now all players have started all their LPmud sessions in one
single room, /room/church. In LPmud 3.0 we are changing this. Players
will start in different places depending on race and guild membership.
    
New players will start in separate rooms determined by their race.
This will be the place where the player starts his LPmud sessions
until he finds a place that allows him to change the starting point.

Every domain will be allowed to have one starting point, either a
default starting location or a temporary starting location. A default
starting locations is a place where the player starts his sessions
every time he logs on, until he chooses to change it. This is
typically used by guilds to allow members to start the game in the
guild. This function could possibly later be used for allowing a
mortal to own a private house or room in the game and start there.

Temporary starting locations can be used for implementing inns or
other places where the player starts only the next time he logs on.
There should always be a cost for staying at the temporary starting
location. Changing to a new starting location should be made by the
player, i.e you may not change it without the player wanting you to do
it. For consistency the command for changing default starting location
should be 'start here'.

In order to start using a starting location, the wizard must get it
registered by an archwizard or a keeper. Otherwise it will not work.

Wizards will start the game in a special room. The reason for this is
to minimize the contact between wizards and mortals.

The following functions are available for setting starting locations:

int set\_default\_start\_location(str)

Sets the defaults starting location to the room defined by str. Str
should be a string containing the pathname of the room. This function
sets the variable default\_start\_location in the player object. A check
is made to ensure that a registered location is given as argument. If
it is not registered 0 is returned, otherwise the return value is 1.

int set\_temp\_start\_location(str)

Sets the temporary starting location to the room defined by str. Str
should be a string containing the pathname of the room. The function
sets the variable temp\_start\_location in the player object. A check is
made to ensure that a registered location is given as argument. If it
is not registered 0 is returned, otherwise the return value is 1. The
variable temp\_start\_location is set to 0 next time the player logs on.

{\em Example:}

\begin{verbatim}
this\player()->set\temp\start\location("/players/fatty/hut");
\end{verbatim}

The following commands are available:

allow\_default place

Adds the room "place", which should be a pathname, to the array
containing valid default starting locations. A check is made to see
that the file really exists. This command is only available to
archwizards and keepers.

allow\_temp place

Adds the room "place", which should be a pathname, to the array
containing valid temporary starting locations. A check is made to see
that the file really exists. This command is only available to
archwizards and keepers.


\subsection{teams}

DO NOT CHANGE THIS FILE! IT HAS ALREADY BEEN INCORPORATED IN THE GLOBAL
DOCUMENTATION. CHANGE LPmud.texinfo INSTEAD.

This document describes how teams work in 3.0

{\bf Background}

There has been very little support for teams in the game before version 3.0.
Teams are basically an idea from the world of roleplaying. When players
cooperate the game should support group movement and sharing of xp.

{\bf Implementation in 3.0}

There are team leaders and team members. Teams are not limited to players, any
living object can join a team. The basic routines in /std/living allows any
mix in a team, however in the player files and in the npc files there are
guards against mixed teams, so no mixed player/NPC teams are allowed.

There are three basic routines in all living objects to handle teams:

\begin{verbatim}
    set_leader(leader_object);  /* Sets the leader to leader_object */
    team_join(member_object);   /* Adds this member to my team */
    team_leave(member_object);  /* Removes this member from my team */
\end{verbatim}

Players have the commands:

\begin{verbatim}
    "invite member_name"    -- To let another player join my team
    "join leader_name"      -- To join a team.
    "leave leader_name"     -- To leave a team.
    "leave member_name"     -- To force a member out of your team
\end{verbatim}

{\bf Consequences in the game}

Team members move by following their leader. Teams share every xp gained by 
anyone in the team. However, this is only true if the team members are in
the same room. So, two rules:

\begin{itemize}
    \item  If your leader is in your room, and the leader moves, you follow.
    \item  If a member of a team gains xp, it is shared by all members in the
      room.
\end{itemize}

{\bf Further development}

The concept of teams will be developed further. The stat 'DIS' disciplin will
be used for deciding who can lead whom. It will also for the leader be
affected by the teams success or failure. It will not be good for a leaders
'DIS' if a member of the team dies.


\subsection{trade}

We all like to code shops, banks, traders and all sorts of things
handling money but there are some rules and recommendations to
follow.

Remember that there is a trading skill. Please consider it and
let players with high skill get better deals, some \%. There is
also nothing wrong to let players of different races or different
guilds get some \% better or worse deals. I don't think dwarves 
and elves never understood eachother, perhaps elves won't even
trust dwarves in their shops or banks? Be creative :)

{\bf Shops}

It has to be more expensive for the players to buy stuff from a
shop than for the shop to buy it from the player (i.e. sell). Yes
I have seen shops where there were no difference :( 

A standard shop shall not give out any gold nor platinum and
should demand the player to pay twice the value of the goods
when buying. Also a standard shop should not give out more than
1000 cc (copper coins) for one item.

{\bf Bank}

If you have a bank where players can deposit their money you should
let them pay for it, not give them intrest or anything like that.

When changing money at a standard bank should take a fee of
20\% of the value of the transaction. How you want them to pay is up
to you just as long as you make them pay *grin* .
Remember that if you change all your copper coins to platinum coins
you will have lowered the weight you are carrying up to 1728 times!
That ought to be worth something ??


\subsection{unarmed\_combat}

This file documents some specific details of unarmed combat.

Unarmed combat is implemented as a separate object that can be inherited
into the living object. It manages the setting of the attacks and hitlocation
values. For each attack the following function can be used:

\begin{verbatim}
    set_attack_unarmed(int aid,       /* The attacks id (see 'combat')
               int wchit,     /* The wc 'to hit' value */
               int wcpen,     /* The wc penetration */
               int dt,        /* The damage type */
               int puse,      /* %use */
               string adesc)  /* Attack description */
\end{verbatim}

As can be seen this is the exact same parameters as sent to add\_attack with
one parameter added for description of the attack. For non tool users this
will be exactly equivalent to using add\_attack() and your own cr\_attack\_desc(),
see /doc/examples/tiger1.c and /doc/examples/tiger2.c for an example of this.

Similarly for each hit location the following function can be used:

\begin{verbatim}
    set_hitloc_unarmed(int hid,      /* The hitloc id (see 'combat') */
               int *ac,      /* The ac for the damage types */
               int phit,     /* The %hit */
               string hdesc) /* Hitloc description */
\end{verbatim}

As you can see this is exactly the same as for add\_hitloc(). It is still
relevant as the object will manage cr\_configure() for you.

For tool users, the combat object will automatically set the attack and
hitlocation values back to the above given when weapons and / or armours are
removed.

There are two different objects that can be
inherited:

\begin{itemize}
\item{\bf /std/combat/unarmed} \\
        This is the 'open' version. You can define what attacks
        and hitlocations you like. 
        NOTE!
        If you have a humanoid with more than the predefined
        attacks and hitlocations you must use this object.

\item{\bf /std/combat/humunarmed} \\
        This is the 'closed' version. There is predefined
        attacks and hitlocations, and you can only change the
        values for them.
\end{itemize}

\begin{verbatim}
    *
    * Doc is to be continued
    *
    * Example: /doc/examples/mobiles/tiger2.c uses /std/combat/unarmed.c
    *
\end{verbatim}


\subsection{userids}

This file documents how the system with userids work:

{\bf Basics}

The system with userids is used to know who is responsible for each object 
in the game. The rights of an object depends on the rights of the userids it
carries. This includes read, write, snoop, possess and many other things.

Every object in the game have two separate userids. 

\begin{itemize}
    \item{\bf uid} This indicates who is responsible for a specific instance
          of an object.

    \item{\bf euid} This indicates who is currently responsible for the
          objects actions.
\end{itemize}

There is a third indirect userid, which is not stored in the object but is
a direct function of the filename.

\begin{itemize}
    \item{\bf cuid} This indicates who is responsible for the sourcecode of
          the object.
\end{itemize}

Userids are strings, normally wizard or domain names. The game driver has
no concept of what these strings are. The name system is entirely up to
the master object. 

There is five efuns that is used to set and check userids:

\begin{itemize}
    \item{\bf getuid(object)} Get the uid of an object.

    \item{\bf geteuid(object)} Get the euid of an object.

    \item{\bf setuid()} Set uid = cuid for the current object.
                  The master object is queried by calling 
                  'creator\_file', for the cuid of the
                  current objects filename.
    
    \item{\bf seteuid(userid)} Set the euid = userid.
                  The master object is queried by calling
                  'valid\_seteuid' to see if the current
                  object has the right to set its euid
                  to the given name.

    \item{\bf export\_uid(object)} Set the uid of 'object' to the euid of
                  the current object. This is only possible
                  if the euid of the recieving object is 0.
\end{itemize}

{\bf Creation of objects and userids}

When an object is loaded or cloned it is given a uid and an euid. There are
two main rules:

\begin{itemize}
\item{\bf 1)} If getuid(creator) == cuid
        uid = euid = geteuid(creator);

\item{\bf 2)} If getuid(creator) != cuid
        uid = cuid
        euid = 0
\end{itemize}

Where 'creator' is the object that forces the clone/load and cuid is the
the name returned by masters 'creator\_file' for the new object.

There are some specific exceptions:

\begin{itemize}
\item  The 'creator' must have a euid. If the euid of the creator is 0 than it
  is not possible to load/clone new objects.

\item  To be allowed to be loaded/cloned the object must have a cuid. This means
  that the master object is queried for 'creator\_file' and if the master
  does not return a string, than the object is denied to be loaded/cloned.

\item  If the cuid is a specific 'backbone' userid, then rule 1 above is applied.
  The 'backbone' userid is a name supplied by master through the function
  'get\_bb\_uid()'

\item  When the master object is loaded, there is no creator. The uid and euid of
  the master object is set after the object is loaded and the function
  'get\_root\_uid()' is called. The name returned is used as uid and euid. This
  is normally the string "root".

\item  When the simul\_efun object is loaded, there is no master object loaded yet.
  The uid is therefore set to the string "NONAME". This is the only hardcoded
  userid in the gamedriver. The uid and euid of the simul\_efun object must
  be set to something correct by the master object as soon as it loads.
\end{itemize}

{\bf Changing of userids}

An object can change its uid and its euid. It can also change the uid of
another object if that object has no euid.

The following rules apply:

\begin{itemize}
\item{\bf 1)}   An object can always change its own uid to its cuid. This is done
    by the efun: setuid().

\item{\bf 2)}   An object can always set its euid to its uid or to 0.
    This is done by: seteuid(userid)

\item{\bf 3)}   An object can set its euid to anything that the master object allows.
    This is done by: seteuid(userid), the gamedriver then calls the
    master objects 'valid\_seteuid' which returns true or false depending
    on if the operation is allowed or not.

\item{\bf 4)}   An object can always set the uid of another object to its own euid
    if the other objects euid is 0. This is done with: export\_uid(object).
\end{itemize}

{\bf Special considerations}

These rules are not coded into the gamedriver but they are implemented in
the login object and in the master object. They are part of the userid design
but might be done differently.

\begin{itemize}
\item  All wizards, when logging in, gets their own name as uid and euid. 

\item  All mortals, when logging in, gets the 'backbone' userid as uid and euid.
\end{itemize}

As objects 'inherits' their userids from the object that forces their load
or clone some special situations may occur.

When rooms are loaded because they are entered for the first time they could
be loaded by any object. Normally a 'player' or another room. As there are
'border' cases between areas and as players have the 'backbone' uid, most rooms
will be given userids according to rule 2 above. That is their uid will be 
equal to their cuid and their euid will be 0.

This is problematic because rooms often clone objects. To make this possible
all rooms use the combination: 
    
        setuid(); seteuid(geteuid(this\_object())); 

to ensure that they are always capable of loading and cloning with the rights
of the wizard who wrote the room.

When a wizard clones or forces an object to load from another wizards
directory rule two above applys, the same as for rooms. This means that if
the object is to be used with the cloning wizards rights, the cloning wizard
must actively set the userids in the loaded/cloned object.

There is normally a command 'trust \verb+<+ob\verb+\verb+>++' for this purpose.


\subsection{values}

This is a documentation of the values of some examplified items. This is
meant as a guideline for setting values on things.

The monetary system is based on the number 12. It is rumored that this is
because gnomes have six fingers / hand although this is dubious.

There is 12 copper coins on a silver coin, 12sc on a gold coin and 12gc
on a platinum coin. All values are given in copper below.

There is one golden rule for values:

\begin{verbatim}
     -------------------------------------------------------------
     Nothing is more valuable than Fatty's weight in gold.
     -------------------------------------------------------------  
\end{verbatim}

Below is the list of value formulas for specific items in copper coins:

\begin{verbatim}
Weapons              50 + ((wchit * wcpen * min(wchit,wcpen)) / 4)
Armours              50 + ((ac * ac * 2))
Liqour healing       10 + (alco * alco / 10)
Magic object healing 5 * hp + hp * hp / 4
Magic spell healing
 (cost of component) hp * 20 
\end{verbatim}

Below is a list of example items and their values:

\begin{verbatim}
  Beer    alc5            12cc
  Special spirits alc25   72cc
  Firebreather alc50     260cc
  Knife wc5               81cc
  Sword wc30            6800cc  
  Armour ac5             100cc
  Armour ac30           1850cc  
  Lantern                100cc 
  Lantern oil             20cc (1cc / 120 heartbeats)
  Torch                    5cc (1cc / 60 heartbeats)
  Rope                   100cc (1cc / 10 kgm)
  Piece of hide            1cc         (for writing on)
  Sack                    24cc 
  Backpack               350cc  
  Healpotion 50hp        875cc
  Healing component 40hp 800cc (Typically pulverized gemstones)
\end{verbatim}  

All prices can of course vary depending on quality, beauty, ornamentation etc.

Note also that the most common coins are copper and silver. Gold and
especially platinum is very rare and should not be traded with generally.
In other words, banks and shops accepts gold and platinum gladly but are
\_very\_ reluctant to hand it out.

Note that even though armours seem a lot cheaper than weapons, this is
more or less an illusion for ac and wc less than 30. This is so because
in normal combat only one weapon is used but 7-8 armours. This will
effectively multiply the armour cost with a factor of 7-8.


\subsection{weapon}

Weapons should be created by cloning or inheriting the file
"/std/weapon.c". The weapon can then easily be configured by calling
the internal functions as described in the file.

Weapons can be configured to cause damage in four different ways.
They can be impaling, slashing, crushing or cause damage magically.
Armours can be configured to have different AC for different weapon-
types.

A weapon two wc values, both a "to hit" value and a "penetration" value. The
"to hit" value together with the weapon skill of the attacker, is
set against the parry capability and dexterity of the enemy.
The penetration value is set agains the armourclass of the enemy. 

When creating a weapon, certain rules must be respected. A weapon
bought in a shop can never be of very good quality as compared to a
weapon found as the result of a tricky quest for example. Some
differences are found primarily in that a weapon is bulkier than
others, this table gives some guidelines:

\begin{verbatim}
    GUIDANCE FOR WEAPONS

    Max WC found (on the ground)    :  10
    Max WC bought                   :  30
    Max WC conquered (in combat)    :  60
    Max WC reward for solving quest :  20 * questlevel (see xp_scale)
    
                        ** Damagetypes allowed **
                        
    weapontype        max WC      Impale    Slash   Bludgeon 

    SWORD (1 handed)    80          X         X              
    SWORD (2 handed)    100         X         X              
    POLEARM             50          X                        
    AXE                 90                    X         X    
    KNIFE               30          X         X              
    CLUB                60                              X    
    MISSILE             30          X                   X    
    JAVELIN             40          X                        

    any magical weapon  100         X         X         X    
\end{verbatim}

Note that there are two max limits for a specific weapon. Both a wc-limit
on how a weapon is gained and a wc-limit for a specific weapon type.

The weapontypes does not exclude other weapons than those named as types. 
All weapons must however be put in one of the above categories.

Note that very intresting weapons can be made if the difference between
the 'to hit' wc is very different from 'penetration' wc. Note also the
significance for the value of a weapon when wchit is different from
wcpen. The standard value for a weapon in copper coins is given by
the formula:

        $cc = 50 + ((wchit * wcpen * min(wchit,wcpen)) / 4)$


\subsection{weight}

All things, including money, has a weight. Weight is a property of each
object (see properties/object). Weight is assigned to an object in gram.
All coins weigh approx 20 grams for example.

A player can carry 10kg + an additional kg for each point of strength. Making
a player with strength 50 able to carry 60kg. 


\subsection{wizinfo}

    To simplify for other wizards you can add the an information 
    property: OBJ\_WIZINFO to your object.

    {\em OBJ\_WIZINFO}  returns the name of a function in the object to call
    for helptext. There will be support in the wizard
    commands for polling an object for info. The wizard
    will give the command: info 'item' [arg]

    'item' is a special definition to be able to refer
    to any object in the game, see docs on the wizard
    commands. [arg] will be passed to the function
    returned by the property OBJ\_WIZINFO.

    {\em Example:}
    
\begin{verbatim}
            >help knife use
\end{verbatim}

            and the knife has defined (OBJ\_WIZINFO,"help")
            will call help("use") in the knife object. Which can
            then write something like:

\begin{verbatim}    
             This knife was made by Mrpr to be used in the
             pyramid quest. Most useful for mortals level 4-9.
             No special functions in the knife but the mortal has
             to present this knife as a gift to gatekeeper in
                 /players/mrpr/entrance1 to be allowed to pass.
\end{verbatim}



\subsection{xp\_scale}

A players stats are a direct function of the amount of xp gathered for
a specific stat, see 'experience'. Note that the player decides what
stats to 'practice', xp are not given separately for each stat. The 
division takes place internally within a player.

A stat of 100 is equivalent to 1.000.000 xp. This means that a player will
need on the average 6.000.000 xp to become wizard.

There is one basic rule for giving xp on solving quests above questlevel 0:

\begin{verbatim}
   -----------------------------------------------------------------
   You may not give more xp for a quest than the player already has.
   -----------------------------------------------------------------
\end{verbatim}

Note that players start with an average of 10 in all stats, this 

Here are some examples of differently sized quests and how much normal
xp to give. Treat these as size examples and not at all by content. The idea
is to let your imagination fly :-)

\begin{itemize}
\item{\bf 1 - 50} Touristing  - 'I was there before Kilroy' 
        A very small 'quest'. Normally simply to find some specific
       (0)  location. Should not take a long time nor be difficult.
        Used for utter novices to get around a bit and see the
        different parts of the mud.

\item{\bf 50 - 100} Serious tourist - 'Exploring is fun, mind the details'
        A small 'quest'. Might be to locate a specific object 
       (0)  somewhere. Might take some thought but shouldn't be
        dangerous.

\item{\bf 100 - 1000} The minor assignment - 'I am a true adventurer!'
        Should actually solve something, might be to slay the nasty
        wolf plaguing the farmers in the village, solve a riddle or
       (1)  bring back some treasure or specific object. Can be both
        difficult and dangerous for beginners.

\item{\bf 1000 - 10000} Small adventure - 'Be bold and prosper!'
        This is a small scale quests, maybe in some stages, might take
       (2)  some time and be both dangerous and/or difficult for the
            not so well prepared.
 
\item{\bf 10000 - 50000} Major adventure - 'This comes to be an occupation, brothers!'
        Should take some time and serious thinking, might well
       (3)  demand team work and cooperation. Could be in a couple of
        stages and be quite a challange.

\item{\bf 50000 - 100000} Normal quests - 'Brothers in arms, roaming the world'
                These are the normal quests, mostly solved by an
       (4)  experienced team of adventurers. There can be many types
        of difficulties and dangers. These are never easy to solve
        and should include challanges to both mind and muscle.

\item{\bf 100000 - 900000} The Ultimate Quests - 'Behold the mighty!'
                This is the quests for the 'soon to be wizards'. Here are
        the true mights in the world revelead together with the
       (5)  challanges and difficulties that make a true LPmud quest.
        There is usually only one such quest/domain and it is the
        true brainchild and effort of the domain set in code.
\end{itemize}

The numbers in paranthesis indicates questlevel. This is used to decide
the maximum rewards when solving the quest. (see weapon and armour)

The actual amount of xp delivered might be made to depend on a lot of things,
the truly nice quests are the ones where the player gets more xp for a
more brilliant solution. Fooling NPC's might be better than killing them.

Normal xp's are not shared. Each player should get the relevant amount of xp
for taking part in solving the quest. It is only combat xp which is given
in a specific amount when a monster is killed which is split among players.

Some important points to notice:

\begin{itemize}
    \item  Demand that the difficulty in the quest not be able to be handled
      by one teammember alone. An utter novice should not be able to
      solve an ultimate quest just because he is a member of an
      experienced team. It could of course count as a minor adventure
      for the novice, use common sense ;-)

    \item  Use stages. It is more rewarding to solve part by part than 
      getting all the xp reward in a cataclysmic ending.

    \item  Document the quest bits used. Once assigned for a purpose that
      purpose can not be changed.

    \item  Quests of level 0-4 are the responsibility of the Lord of the domain,
      the ultimate quest, level 5, must be acknowledged by an Arch or a
      keeper.
\end{itemize}

And the ONE rule again:
\begin{verbatim}
   -----------------------------------------------------------------
   You may not give more xp for a quest than the player already has.
   -----------------------------------------------------------------
\end{verbatim}
