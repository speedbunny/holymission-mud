\section{Local Functions (lfun)}

\subsection{armour}
\subsubsection{check\_armour}

{\em /std/armour.c () check\_armour()}

Check file for security.


\subsubsection{comp\_value}

{\em /std/armour.c () comp\_value(int ac)}

Compute the base value of the armour.

{\bf Arguments:}
\begin{itemize}
\item     ac - The armour class.
\end{itemize}

{\bf Returns:}        The cost.


\subsubsection{create\_armour}

{\em /std/armour.c () create\_armour()}

Reset the armour


\subsubsection{init}

{\em /std/armour.c () init()}

Initialize some armour related actions.


\subsubsection{leave\_env}

{\em /std/armour.c () leave\_env(object from, object to)}


{\bf Arguments:}
\begin{itemize}
\item     from - Where from
\end{itemize}


\subsubsection{remove\_arm}

{\em /std/armour.c () remove\_arm(string what)}

Unwear the armour.

{\bf Arguments:}
\begin{itemize}
\item     what: What to remove.
\end{itemize}


\subsubsection{reset\_armour}

{\em /std/armour.c () reset\_armour()}

Reset the armour (default)


\subsubsection{set\_default\_armour}

{\em /std/armour.c () set\_default\_armour(ac, at, am, af)}


{\bf Arguments:}

{\bf Returns:} 


\subsubsection{short}

{\em /std/armour.c () short()}

Return the short description of the armour.


\subsubsection{wear\_arm}

{\em /std/armour.c () wear\_arm(string what)}

wear the armour.

{\bf Arguments:}
\begin{itemize}
\item     what: what to wear.
\end{itemize}


\subsection{container}
\subsubsection{create\_container}

{\em /std/container.c (public) create\_container()}

Reset the container (standard)


\subsubsection{create\_object}

{\em /std/container.c (public) create\_object()}

Create the container (constructor)


\subsubsection{enter\_inv}

{\em /std/container.c (public) enter\_inv(object ob, object from)}

Called when objects enter this container or when an
object has just changed its weight/volume/light status.

{\bf Arguments:}
\begin{itemize}
\item      ob: The object that just entered this inventory
\item from: The object from which it came.
\end{itemize}


\subsubsection{leave\_inv}

{\em /std/container.c (public) leave\_inv(object ob, object to)}

Called when objects leave this container or when an
object is about to change its weight/volume/light status.

{\bf Arguments:}
\begin{itemize}
\item      ob: The object that just leaved this inventory
\item to: Where it went.
\end{itemize}


\subsubsection{light}

{\em /std/container.c (public) light()}

Returns the light status in this container
This function is called from query\_prop() only.

{\bf Returns:}    Light value


\subsubsection{notify\_change\_prop}

{\em /std/container.c (public) notify\_change\_prop(string prop, mixed val, mixed old)}

This function is called when a property in an object
in the inventory has been changed.

{\bf Arguments:}
\begin{itemize}
\item     prop - The property that has been changed.
\item val  - The new value.
\item old  - The old value.
\end{itemize}


\subsubsection{query\_internal\_light}

{\em /std/container.c (public) query\_internal\_light()}

Returns the lightvalue of object internal to this container

{\bf Returns:}    Lightvalue


\subsubsection{query\_sublocs}

{\em /std/container.c (public) query\_sublocs()}

Get the current list of sublocations for this container


\subsubsection{reset\_container}

{\em /std/container.c (public) reset\_container()}

Reset the container (standard)


\subsubsection{reset\_object}

{\em /std/container.c (public) reset\_object()}

Reset the container 


\subsubsection{set\_room}

{\em /std/container.c (public) set\_room(mixed room)}

Connects a room to the internals of the container.

{\bf Arguments:}
\begin{itemize}
\item     room: The room object or a filename
\end{itemize}


\subsubsection{show\_subloc}

{\em /std/container.c (public) show\_subloc(string sloc)}

Give a description of one sublocation. This is a default
routine meant to be replaced by a configured routine.

{\bf Arguments:}
\begin{itemize}
\item      sloc: Name of sublocation
\end{itemize}


\subsubsection{show\_sublocs}

{\em /std/container.c (public) show\_sublocs()}

Give a description of each sublocation. This is a default
routine merely calling show\_subloc(name) for each.


\subsubsection{subinventory}

{\em /std/container.c (public) subinventory(mixed sloc)}

Give the subinventory for a specific sublocation

{\bf Arguments:}
\begin{itemize}
\item      sloc: sublocation
\end{itemize}


\subsubsection{update\_internal}

{\em /std/container.c (public) update\_internal(int l, int w, int v)}

Updates the light, weight and volume of things inside
also updates a possible environment.

{\bf Arguments:}
\begin{itemize}
\item      l: Light diff.
\item w: Weight diff.
\item v: Volume diff.
\end{itemize}


\subsubsection{voidset\_room}

{\em /std/container.c (public) voidset\_room(mixed room)}

Connects a room to the internals of the container.

{\bf Arguments:}
\begin{itemize}
\item     room: The room object or a filename
\end{itemize}


\subsubsection{volume}

{\em /std/container.c (public) volume()}

Returns the volume of the container. How much volume it
currently takes up, a nonrigid sack accumulates this.
This function is called from query\_prop() only.

{\bf Returns:}    Volume value


\subsubsection{volume\_left}

{\em /std/container.c (public) volume\_left()}

Returns the volume left to fill.

{\bf Returns:}    non\_negative integer


\subsubsection{weight}

{\em /std/container.c (public) weight()}

Returns the accumulated weight of the container.
This function is called from query\_prop() only.

{\bf Returns:}    Weight value


\subsection{door}
\subsubsection{add\_door\_info}

{\em /std/door.c (static) add\_door\_info(object dest)}

Add information about this door to the room it
stands in. If this door already exists, autodestruct.

{\bf Arguments:}
\begin{itemize}
\item     dest - The room that contains the door.
\end{itemize}


\subsubsection{close\_door}

{\em /std/door.c () close\_door(string arg)}

Close the door.

{\bf Arguments:}
\begin{itemize}
\item     arg - arguments given
\end{itemize}


\subsubsection{create\_door}

{\em /std/door.c () create\_door()}

Sets default names and id


\subsubsection{create\_object}

{\em /std/door.c () create\_object()}

Initialize object.


\subsubsection{enter\_env}

{\em /std/door.c () enter\_env(object dest, object old)}

The door enters a room, activate it.

{\bf Arguments:}
\begin{itemize}
\item     dest - The destination room,
\item old - Where it came from
\end{itemize}


\subsubsection{init}

{\em /std/door.c () init()}

Initalize the door actions


\subsubsection{leave\_env}

{\em /std/door.c () leave\_env(object old, object dest)}

The door leaves a room, remove it.

{\bf Arguments:}
\begin{itemize}
\item      old - Where it came from,
\item dest - The destination room
\end{itemize}


\subsubsection{load\_other\_door}

{\em /std/door.c () load\_other\_door()}

Try to load the door in the other room. If this
fails, autodestruct.


\subsubsection{lock\_door}

{\em /std/door.c () lock\_door(string arg)}

Lock the door.

{\bf Arguments:}
\begin{itemize}
\item     arg - arguments given
\end{itemize}


\subsubsection{lock\_procedure}

{\em /std/door.c () lock\_procedure(string arg)}

This function is called to determine if
a lock can be locked/unlocked.
Two methods are used here:
\begin{itemize}
\item{\bf 1:} No key. You unlock by typing "\verb+<+command\verb+>+ \verb+<+door\_id\verb+>+".
\item{\bf 2:} Key. You unlock by typing "\verb+<+command\verb+>+ \verb+<+door\_id\verb+>+ with \verb+<+key\_id\verb+>+".
\end{itemize}

{\bf Arguments:}
\begin{itemize}
\item     arg - the argument given to the command lock/unlock
\end{itemize}

{\bf Returns:}        1 - Ok, 0 - Fail.


\subsubsection{open\_door}

{\em /std/door.c () open\_door(string arg)}


{\bf Arguments:}
\begin{itemize}
\item     arg - arguments given
\end{itemize}


\subsubsection{pass\_door}

{\em /std/door.c () pass\_door(string arg)}

Pass the door.

{\bf Arguments:}
\begin{itemize}
\item     arg - arguments given
\end{itemize}


\subsubsection{query\_other\_door}

{\em /std/door.c () query\_other\_door()}

Get the other door object pointer. The other
door will be loaded if neccesary. If that proovs
impossible, this door will autodestruct.


\subsubsection{remove\_door\_info}

{\em /std/door.c (static) remove\_door\_info(object dest)}

Remove information about this door from the room it
stands in.

{\bf Arguments:}
\begin{itemize}
\item     dest - The room that contains the door.
\end{itemize}


\subsubsection{unlock\_door}

{\em /std/door.c () unlock\_door(string arg)}

Unlock the door.

{\bf Arguments:}
\begin{itemize}
\item     arg - arguments given
\end{itemize}


\subsection{humanoid\_combat}
\subsubsection{adjust\_ac}

{\em /std/humanoid\_combat.c (static) adjust\_ac(int aslot, object arm, int rm)}

Adjust relevant hitlocations for a given armour slot
when we wear an armour or remove an armour.

{\bf Arguments:}
\begin{itemize}
\item     aslot: The armourslot as given in /sys/wa\_types.h
\item arm:   The armour.
\item rm:    True if we remove armour
\end{itemize}


\subsubsection{aslot\_protects}

{\em /std/humanoid\_combat.c (static) aslot\_protects(int aslot, object arm)}

Give an array of the bodyparts protected by a given
aslot.

{\bf Arguments:}
\begin{itemize}
\item     aslot: The armourslot as given in /sys/wa\_types.h
\item arm:   The armour.
\end{itemize}


\subsubsection{attack\_desc}

{\em /std/humanoid\_combat.c (static) attack\_desc(int aid)}

Gives the description of a certain attack slot.

{\bf Arguments:}
\begin{itemize}
\item      aid:   The attack id
\end{itemize}

{\bf Returns:}        string holding description


\subsubsection{cb\_configure}

{\em /std/humanoid\_combat.c () cb\_configure()}

Configure humanoid attacks and hitlocations.

{\bf Returns:}        True if hit, otherwise 0.


\subsubsection{cb\_damage}

{\em /std/humanoid\_combat.c () cb\_damage(int wcpen, int ac, object att, object def)}

Routine for deciding damage on a given wcpen/ac

{\bf Arguments:}
\begin{itemize}
\item     wcpen:    Weapon class penetration of attack
\item ac:       Armour class against attack
\item att:      Attacker
\item def:      Defender
\end{itemize}
public int


\subsubsection{cb\_did\_hit}

{\em /std/humanoid\_combat.c (public) cb\_did\_hit(int aid, string hdesc, int phurt, object enemy)}

Tells us that we hit something. Should produce combat
messages to all relevant parties. 

{\bf Arguments:}
\begin{itemize}
\item      aid:   The attack id
\item hdesc: The hitlocation description.
\item phurt: The \%hurt made on the enemy
\item enemy: The enemy who got hit
\end{itemize}


\subsubsection{cb\_query\_armour}

{\em /std/humanoid\_combat.c (public) cb\_query\_armour(int which)}

Returns the armour of a given position.
A list of all if illegal argument is given.

{\bf Arguments:}
\begin{itemize}
\item     which: A numeric label describing an armour
\item location. On humanoids this is A\_HEAD etc.
\end{itemize}

{\bf Returns:}        The corresponding armour


\subsubsection{cb\_query\_weapon}

{\em /std/humanoid\_combat.c (public) cb\_query\_weapon(int which)}

Returns the weapon held in a specified location.
Illegal location gives a list of all.

{\bf Arguments:}
\begin{itemize}
\item     which: A numeric label describing a weapon
\item location. On humanoids this is W\_RIGHT etc.
\end{itemize}

{\bf Returns:}        The corresponding weapon.


\subsubsection{cb\_show\_wielded}

{\em /std/humanoid\_combat.c (public) cb\_show\_wielded()}

Describe the currently wielded weapons.

{\bf Returns:}        Description string.


\subsubsection{cb\_show\_worn}

{\em /std/humanoid\_combat.c (public) cb\_show\_worn()}

Describe the currently worn armours

{\bf Returns:}        Description string.


\subsubsection{cb\_tohit}

{\em /std/humanoid\_combat.c (public) cb\_tohit(int aid, int wchit, object vic)}

Decide if we hit our victim or not

{\bf Arguments:}
\begin{itemize}
\item      aid:   The attack id
\item wchit: Weapon class 'to hit'
\item vic:   The intended victim
\end{itemize}

{\bf Returns:}        True if hit, otherwise 0.


\subsubsection{cb\_unwield}

{\em /std/humanoid\_combat.c (public) cb\_unwield(object wep)}

Unwield a weapon.

{\bf Arguments:}
\begin{itemize}
\item     wep - The weapon to unwield.
\end{itemize}

{\bf Returns:}        None.


\subsubsection{cb\_wear\_arm}

{\em /std/humanoid\_combat.c (public) cb\_wear\_arm(object arm)}

Wear an armour

{\bf Arguments:}
\begin{itemize}
\item     arm - The armour.
\end{itemize}

{\bf Returns:}        True if worn


\subsubsection{cb\_wield\_weapon}

{\em /std/humanoid\_combat.c (public) cb\_wield\_weapon(object wep)}

Wield a weapon.

{\bf Arguments:}
\begin{itemize}
\item     wep - The weapon to wield.
\end{itemize}

{\bf Returns:}        True if wielded.


\subsubsection{create\_xcombat}

{\em /std/humanoid\_combat.c (public) create\_xcombat()}

Reset the combat functions


\subsubsection{fixnorm}

{\em /std/humanoid\_combat.c (static) fixnorm(int offence, int defence)}

Normalize offensive / defensive values


\subsection{living}
\subsubsection{acc\_exp\_to\_stats}

{\em /std/living/stats.c (static) acc\_exp\_to\_stats()}

Translates the current accumulated exp into stats.


\subsubsection{add\_age}

{\em /std/living/savevars.c () add\_age(int a)}

Internal age.


\subsubsection{add\_fatigue}

{\em /std/living/savevars.c (public) add\_fatigue(int f)}

Sorry (Will be documented later, use man -s)


\subsubsection{add\_heart\_beat}

{\em /std/living/heart\_beat.c (public) add\_heart\_beat(string func, object obj)}

Add a heart\_beat function to the livings's list.

{\bf Arguments:}
\begin{itemize}
\item     func - The name of the function to call.
\item obj - The object to call the function in. 
\end{itemize}

{\bf Returns:}        1 - Ok, 0 - The spell already existed.


\subsubsection{add\_mana}

{\em /std/living/savevars.c () add\_mana(int sp)}

Mana 
(Spellpoints, magic points or whatever you want to call them)


\subsubsection{add\_spellobj}

{\em /std/living.c () add\_spellobj(object obj)}

Add a spell object to the list of spell objects.

{\bf Arguments:}
\begin{itemize}
\item     obj - The object to add.
\end{itemize}


\subsubsection{add\_tmp\_stat}

{\em /std/living/stats.c (public) add\_tmp\_stat(int stat, int ds, int dt)}

add a temporary stat.

{\bf Arguments:}
\begin{itemize}
\item      stat - which stat
\item ds - change in stat
\item dt - How many heartbeats (x 10) to keep the change.
\end{itemize}

{\bf Returns:}        1 - Ok, 0 - Change rejected.


\subsubsection{adjust\_combat\_on\_move}

{\em /std/living/combat.c (public) adjust\_combat\_on\_move(int leave)}

Called to let movement affect the ongoing fight. This
is used to print hunting messages.

{\bf Arguments:}
\begin{itemize}
\item     True if leaving else arriving
\end{itemize}


\subsubsection{arrive}

{\em /std/living/move.c (static) arrive(string how)}

Tell you are arriving to surrounding object.


\subsubsection{attack}

{\em /std/living/combat.c (static) attack(int num)}

Do 1 round of fighting with the enemy

{\bf Arguments:}
\begin{itemize}
\item      num: 0 if normal heart\_beat call, ignore lost heart\_beats
\end{itemize}

{\bf Returns:}        Return true if there still is a fight.


\subsubsection{attack\_object}

{\em /std/living/combat.c (public) attack\_object(object ob)}

Start attacking, the actual attack is done in heart\_beat

{\bf Arguments:}
\begin{itemize}
\item     The object to attack
\end{itemize}


\subsubsection{attacked\_by}

{\em /std/living/combat.c (public) attacked\_by(object ob)}

This routine is called when we are attacked.

{\bf Arguments:}
\begin{itemize}
\item      ob: The attacker
\end{itemize}


\subsubsection{catch\_msg}

{\em /std/living.c (public) catch\_msg(mixed str, object from\_player)}

This function is called for every normal message sent
to this living. The only exception is efun tell\_object()
and write() which go through catch\_tell().

{\bf Arguments:}
\begin{itemize}
\item      str:       Message to tell the player
\item from\_player: The object that generated the message
\item This is only valid if the message is on the
\item form (\{ "met message", "unmet message" \})
\end{itemize}


\subsubsection{check\_team}

{\em /std/living/move.c (static) check\_team(object ob)}

Check that the team is where "I" am.

{\bf Arguments:}
\begin{itemize}
\item      ob - The team object to check.
\end{itemize}

{\bf Returns:}        Result of check. 1/0.


\subsubsection{clear\_flag}

{\em /std/living/savevars.c (public) clear\_flag(int n)}

Clear a flag.

{\bf Arguments:}
\begin{itemize}
\item      n - The flag to test.
\end{itemize}

{\bf Returns:}        1 - Success, 0 - Failure.


\subsubsection{cmdhooks\_reset}

{\em /std/living/cmdhooks.c (static) cmdhooks\_reset()}

Start the command parsing.


\subsubsection{combat\_init}

{\em /std/living/combat.c (static) combat\_init()}

Notes when players are introduced into our environment
Used to attack known enemies on sight.


\subsubsection{combat\_reset}

{\em /std/living/combat.c (static) combat\_reset()}

Reset the combat functions of the living object.

{\bf Arguments:}
\begin{itemize}
\item     arg: Reset argument.
\end{itemize}


\subsubsection{command}

{\em /std/living.c (public) command(string cmd)}

Makes the living object execute a command

{\bf Arguments:}
\begin{itemize}
\item       cmd: String containing the command
\end{itemize}

{\bf Returns:}      eval\_cost or '0' if unsuccessfull


\subsubsection{communicate}

{\em /std/living/cmdhooks.c (public) communicate(string str)}

Must have it here for special with ' 


\subsubsection{comp\_armour}

{\em /std/living/combat.c (static) comp\_armour()}

Compute the total armour classes.


\subsubsection{create\_container}

{\em /std/living.c () create\_container()}

Create the living object. (constructor)


\subsubsection{create\_living}

{\em /std/living.c (public) create\_living()}

Create the living object. (standard)


\subsubsection{decr\_tmp\_stats}

{\em /std/living/stats.c (public) decr\_tmp\_stats(int num)}

Decrement the temp stat counters and remove 
the additions as they time out.

{\bf Arguments:}
\begin{itemize}
\item      num: 0 if normal heart\_beat call, ignore lost heart\_beats
\item npc's cheat a bit here no heartbeat no statdecrease.
\end{itemize}


\subsubsection{depart}

{\em /std/living/move.c (static) depart(string how)}

Tell you are departing to surrounding object.


\subsubsection{did\_hit}

{\em /std/living/ucombat.c (public) did\_hit(object attacker, int phurt, object defender)}

Used to give combat message to the attacker and the defender

{\bf Arguments:}
\begin{itemize}
\item     attacker: The attacker
\item phurt:    The \% of xp reduced from defenders max.
\item defender: The defender
\end{itemize}

{\bf Returns:}        Message to print to the room.


\subsubsection{do\_die}

{\em /std/living/combat.c (public) do\_die(object killer)}

Called from enemy combat object when it thinks we died.

{\bf Arguments:}
\begin{itemize}
\item      killer: The enemy that caused our death.
\end{itemize}


\subsubsection{do\_glance}

{\em /std/living/move.c (public) do\_glance(int brief)}

Obvious (Will be documented later, use man -s)


\subsubsection{drink\_alco}

{\em /std/living/drink\_eat.c (public) drink\_alco(int strength, int ask)}

Drinks alcohol of a certain potency

{\bf Arguments:}
\begin{itemize}
\item       strength: The strength of the drink
\item ask: True if we only want to know IF we can drink this
\end{itemize}

{\bf Returns:}      True if successfully drunk.


\subsubsection{drink\_heart\_beat}

{\em /std/living/drink\_eat.c (static) drink\_heart\_beat(int num)}

Does heart beat things for drinks / food

{\bf Arguments:}
\begin{itemize}
\item       num: 0 Normal heart beat, \verb+>+0 forgotten heart beats
\end{itemize}


\subsubsection{drink\_max}

{\em /std/living/drink\_eat.c (static) drink\_max()}

Gives the max amount of liquid that we can hold
function from the property: LIVE\_I\_MAX\_DRINK

{\bf Returns:}      Max liquid level.


\subsubsection{drink\_soft}

{\em /std/living/drink\_eat.c (public) drink\_soft(int amount, int ask)}

Drinks a certain amount of liquid

{\bf Arguments:}
\begin{itemize}
\item       amount: The amount of the drink
\item ask: True if we only want to know IF we can drink this
\end{itemize}

{\bf Returns:}      True if successfully drunk.


\subsubsection{eat\_food}

{\em /std/living/drink\_eat.c (public) eat\_food(int amount, int ask)}

Eats a certain amount of food.

{\bf Arguments:}
\begin{itemize}
\item       amount: The amount of food.
\item ask: True if we only want to know IF we can eat this
\end{itemize}

{\bf Returns:}      True if successfully eaten.


\subsubsection{eat\_max}

{\em /std/living/drink\_eat.c (static) eat\_max()}

Gives the max amount of food that we can hold
function from the property: LIVE\_I\_MAX\_EAT

{\bf Returns:}      Max food level.


\subsubsection{fixnorm}

{\em /std/living/combat.c (static) fixnorm(int offence, int defence)}

Normalize offensive / defensive values


\subsubsection{follow\_leader}

{\em /std/living/move.c (public) follow\_leader(string how)}

Obvious (Will be documented later, use man -s)


\subsubsection{glance}

{\em /std/living/move.c (static) glance()}

Take a look at the surrounding object.


\subsubsection{got\_hit}

{\em /std/living/ucombat.c (public) got\_hit(object attacker, int proc\_hurt, object wep, object defe}

der)
Notes that the defender has been hit

{\bf Arguments:}
\begin{itemize}
\item     attacker: The attacker
\item phurt:    The \% of xp reduced from defenders max.
\item wep:      The weapon used to do damage
\item defender: The defender
\end{itemize}


\subsubsection{heal\_hp}

{\em /std/living/savevars.c () heal\_hp(int hp)}

Sorry (Will be documented later, use man -s)


\subsubsection{heal\_living}

{\em /std/living/combat.c (static) heal\_living(int num)}

Heals the living object

{\bf Arguments:}
\begin{itemize}
\item      num: Should be 0, otherwise \verb+>+0 for lost heart\_beats
\end{itemize}


\subsubsection{heart\_beat}

{\em /std/living/heart\_beat.c (static) heart\_beat(int num)}

Perform all heart\_beat routines.

{\bf Arguments:}
\begin{itemize}
\item        num: Number of lost heart beats, sent as argument
\item If num == 0, it's a normal heart\_beat
\end{itemize}


\subsubsection{hit\_notify}

{\em /std/living/ucombat.c (public) hit\_notify(int dam, object wep)}

We got hit by a weapon of some kind.

{\bf Arguments:}
\begin{itemize}
\item     dam - The damage intended.
\item wep - The weapon that hurt me.
\end{itemize}

\subsubsection{hit\_player}

{\em /std/living/combat.c (public) hit\_player(int dam, object with\_weapon)}

Called to make damage on this object. The actually
made damage is returned and will be used to change
the score of the aggressor.

{\bf Arguments:}
\begin{itemize}
\item     Intended damage, Used weapon
\end{itemize}

{\bf Returns:}        None.


\subsubsection{hunter\_starts}

{\em /std/living/combat.c (public) hunter\_starts(object hunter)}

Tells this living that it is now hunted

{\bf Arguments:}
\begin{itemize}
\item     hunter: The one who just started hunting us.
\end{itemize}


\subsubsection{hunter\_stops}

{\em /std/living/combat.c (public) hunter\_stops(object hunter)}

Tells this living that it is no longer hunted

{\bf Arguments:}
\begin{itemize}
\item     hunter: The one who just stopped hunting us.
\end{itemize}


\subsubsection{init}

{\em /std/living.c () init()}

Tells us of new players in our neigbourhood


\subsubsection{init\_gs\_levels}

{\em /std/living/stats.c (public) init\_gs\_levels()}

initialize guild stat level names


\subsubsection{init\_gs\_names}

{\em /std/living/stats.c (public) init\_gs\_names()}

initialize guild stat names


\subsubsection{intoxicated\_max}

{\em /std/living/drink\_eat.c (static) intoxicated\_max()}

Gives the max intoxication level, used as a call
function from the property: LIVE\_I\_MAX\_INTOX

{\bf Returns:}      Max intoxication level.


\subsubsection{intoxicated\_min}

{\em /std/living/drink\_eat.c (static) intoxicated\_min()}

Gives the min intoxication level, used as a call
function from the property: LIVE\_I\_MIN\_INTOX

{\bf Returns:}      Min intoxication level.


\subsubsection{intteam\_join}

{\em /std/living/combat.c (public) intteam\_join(object member)}

Sets this living as the leader of another
Fails if we have a leader, then we can't lead others.

{\bf Arguments:}
\begin{itemize}
\item     member: The objectpointer to the new member of my team
\end{itemize}

{\bf Returns:}        True if member accepted in the team


\subsubsection{light}

{\em /std/living.c (public) light()}

Returns the light status in this living object
Livings are special in that not all carried can be seen
but lights consider livings 'transparent containers'. This
is of course natural as things are carried.
This function is called from query\_prop() only.

{\bf Returns:}    Light value


\subsubsection{load\_command\_souls}

{\em /std/living/cmdhooks.c (public) load\_command\_souls()}

Load the command souls into the player.


\subsubsection{load\_tool\_souls}

{\em /std/living/cmdhooks.c (public) load\_tool\_souls()}

Load the tool souls into the player.


\subsubsection{load\_wiz\_souls}

{\em /std/living/cmdhooks.c (public) load\_wiz\_souls()}

Load the wizard souls into the player.


\subsubsection{long}

{\em /std/living/description.c (public) long(mixed for\_obj)}

Obvious (Will be documented later, use man -s)


\subsubsection{move\_all\_to}

{\em /std/living/combat.c (static) move\_all\_to(object dest)}

Move the entire inventory of this\_object to dest

{\bf Arguments:}
\begin{itemize}
\item      dest: destination of the inventory
\end{itemize}


\subsubsection{move\_living}

{\em /std/living/move.c (public) move\_living(string how, mixed to\_dest)}

Posts a move command for a living object somewhere.

{\bf Arguments:}
\begin{itemize}
\item     how:      The direction of travel for teleportation, "X"
\item to\_dest:  Destination
\end{itemize}

{\bf Returns:}        Result code of move:
0: Success.
3: Can't take it out of it's container.
4: The object can't be inserted into bags etc.
5: The destination doesn't allow insertions of objects.
7: Other (Error message printed inside move() func)


\subsubsection{move\_reset}

{\em /std/living/move.c (static) move\_reset()}

Reset the move module of the living object.

{\bf Arguments:}
\begin{itemize}
\item     arg: Reset argument.
\end{itemize}


\subsubsection{move\_team}

{\em /std/living/move.c (static) move\_team(object ob)}

Move a member of a team in one direction.

{\bf Arguments:}
\begin{itemize}
\item      ob - A teammember to move.
\end{itemize}

{\bf Returns:}        Success of move.


\subsubsection{my\_commands}

{\em /std/living/cmdhooks.c (static) my\_commands(string str)}

Try to find and perform a command.

{\bf Arguments:}
\begin{itemize}
\item      str - the argument string.
\end{itemize}


\subsubsection{notmet\_me}

{\em /std/living/description.c (public) notmet\_me(object obj)}

Finds out if obj is considered to have met me. Players must
have been introduced to me. All others need not have been
introduced.

{\bf Arguments:}
\begin{itemize}
\item      obj: Object in question, has it met me?
\end{itemize}

{\bf Returns:}        True if object has not met me.


\subsubsection{object\_random}

{\em /std/living/stats.c (public) object\_random(int ival, object obj)}

Get a random number depending on player object number
and the given object's object number. This number will
always be the same for a given object.

{\bf Arguments:}
\begin{itemize}
\item     ival - The random number interval,
\item obj - The object.
\end{itemize}

{\bf Returns:}    -1 if the given object doesn't exist.


\subsubsection{query\_Art\_name}

{\em /std/living/description.c (public) query\_Art\_name()}

Gives the name with a capitalized prefix article

{\bf Returns:}      Name prefixed with capitalized article.


\subsubsection{query\_Met\_name}

{\em /std/living/description.c (public) query\_Met\_name()}



\subsubsection{query\_The\_name}

{\em /std/living/description.c (public) query\_The\_name()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_ac\_for}

{\em /std/living/combat.c (public) query\_ac\_for(int type)}

Return the computed ac for a certain type.

{\bf Arguments:}
\begin{itemize}
\item     type - The type of ac to return.
\end{itemize}

{\bf Returns:}        The sought for ac.


\subsubsection{query\_acc\_exp}

{\em /std/living/savevars.c (public) query\_acc\_exp(int stat)}

Get the accumulated xp's for a given stat


\subsubsection{query\_age}

{\em /std/living/savevars.c (public) query\_age()}

How old (in heartbeats) are we.


\subsubsection{query\_al\_title}

{\em /std/living/savevars.c (public) query\_al\_title()}

Sorry (Will be documented later, use man -s)


\subsubsection{query\_alignment}

{\em /std/living/savevars.c (public) query\_alignment()}

Sorry (Will be documented later, use man -s)


\subsubsection{query\_all\_skill\_types}

{\em /std/living/savevars.c (public) query\_all\_skill\_types()}

Gives list of all current skills != 0


\subsubsection{query\_am}

{\em /std/living/ucombat.c (public) query\_am()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_appearance}

{\em /std/living/savevars.c (public) query\_appearance()}

Returns appearance


\subsubsection{query\_at}

{\em /std/living/ucombat.c (public) query\_at()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_attack}

{\em /std/living/combat.c (public) query\_attack()}

Return the attacked object.

{\bf Returns:}        The attacked object.


\subsubsection{query\_average\_stat}

{\em /std/living/stats.c (public) query\_average\_stat()}

Return the average of all stats.


\subsubsection{query\_base\_stat}

{\em /std/living/stats.c (public) query\_base\_stat(int stat)}

returns the value of a stat
{\bf Arguments:}
\begin{itemize}
\item stat is the index in the array of stats
\end{itemize}

\subsubsection{query\_cmdsoul\_list}

{\em /std/living/cmdhooks.c (public) query\_cmdsoul\_list()}

Default cmdsouls for all living objects


\subsubsection{query\_combat\_file}

{\em /std/living/combat.c (public) query\_combat\_file()}

Gives the name of the file to use for combat.


\subsubsection{query\_dt}

{\em /std/living/ucombat.c (public) query\_dt()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_enemy}

{\em /std/living/combat.c (public) query\_enemy(int arg)}

Gives our current enemy that we are fighting

{\bf Arguments:}
\begin{itemize}
\item      arg: Enemy number 0 / 1
\end{itemize}

{\bf Returns:}        Object pointer to the enemy


\subsubsection{query\_exp}

{\em /std/living/savevars.c (public) query\_exp()}

How many exp points do we have (normal + combat)


\subsubsection{query\_exp\_combat}

{\em /std/living/savevars.c (public) query\_exp\_combat()}

How many combat exp points do we have


\subsubsection{query\_fatigue}

{\em /std/living/savevars.c (public) query\_fatigue()}

Sorry (Will be documented later, use man -s)


\subsubsection{query\_gender}

{\em /std/living/savevars.c (public) query\_gender()}

Returns gender code.


\subsubsection{query\_gender\_string}

{\em /std/living/gender.c (public) query\_gender\_string()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_ghost}

{\em /std/living/savevars.c (public) query\_ghost()}

Sorry (Will be documented later, use man -s)


\subsubsection{query\_gs\_level}

{\em /std/living/stats.c (public) query\_gs\_level(int stat, int level)}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_gs\_name}

{\em /std/living/stats.c (public) query\_gs\_name(int stat)}

returns the name of a guild stat
{\bf Arguments:}
\begin{itemize}
\item stat is the index of the required name in the stat array
\end{itemize}


\subsubsection{query\_hands}

{\em /std/living/ucombat.c (public) query\_hands()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_headache}

{\em /std/living/savevars.c (public) query\_headache()}

Sorry (Will be documented later, use man -s)


\subsubsection{query\_heart\_beat\_objs}

{\em /std/living/heart\_beat.c (public) query\_heart\_beat\_objs()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_hit}

{\em /std/living/ucombat.c (public) query\_hit()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_hp}

{\em /std/living/savevars.c (public) query\_hp()}

Sorry (Will be documented later, use man -s)


\subsubsection{query\_hunting}

{\em /std/living/combat.c (public) query\_hunting()}

Gives the object we are hunting

{\bf Returns:}        Object we are hunting


\subsubsection{query\_intoxicated}

{\em /std/living/savevars.c (public) query\_intoxicated()}

Sorry (Will be documented later, use man -s)


\subsubsection{query\_invis}

{\em /std/living/savevars.c (public) query\_invis()}

Sorry (Will be documented later, use man -s)


\subsubsection{query\_leader}

{\em /std/living/combat.c (public) query\_leader()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_learn\_pref}

{\em /std/living/savevars.c (public) query\_learn\_pref(int stat)}


{\bf Arguments:}
\begin{itemize}
\item        Index of learn\_pref or -1
\end{itemize}

{\bf Returns:}          learn\_pref value if arg \verb+>+= 0, 
entire learn\_pref array if arg \verb+<+ 0


\subsubsection{query\_m\_in}

{\em /std/living/savevars.c (public) query\_m\_in()}

Sorry (Will be documented later, use man -s)


\subsubsection{query\_m\_out}

{\em /std/living/savevars.c (public) query\_m\_out()}

Sorry (Will be documented later, use man -s)


\subsubsection{query\_mana}

{\em /std/living/savevars.c (public) query\_mana()}

Sorry (Will be documented later, use man -s)


\subsubsection{query\_max\_fatigue}

{\em /std/living/savevars.c (public) query\_max\_fatigue()}

Sorry (Will be documented later, use man -s)


\subsubsection{query\_max\_hp}

{\em /std/living/savevars.c (public) query\_max\_hp()}

Sorry (Will be documented later, use man -s)


\subsubsection{query\_max\_mana}

{\em /std/living/savevars.c (public) query\_max\_mana()}

Sorry (Will be documented later, use man -s)


\subsubsection{query\_met}

{\em /std/living.c (public) query\_met(mixed name)}

Tells if we know a certain living's name.

{\bf Arguments:}
\begin{itemize}
\item      name: Name of living or objectp of living
\end{itemize}

{\bf Returns:}        True if we know this name otherwise false.


\subsubsection{query\_mm\_in}

{\em /std/living/savevars.c (public) query\_mm\_in()}

Sorry (Will be documented later, use man -s)


\subsubsection{query\_mm\_out}

{\em /std/living/savevars.c (public) query\_mm\_out()}

Sorry (Will be documented later, use man -s)


\subsubsection{query\_name}

{\em /std/living/description.c (public) query\_name()}



\subsubsection{query\_nonmet\_name}

{\em /std/living/description.c (public) query\_nonmet\_name()}

Gives the name of this living to players who has not met
this player.

{\bf Returns:}        The name of the living when unmet.


\subsubsection{query\_npc}

{\em /std/living/savevars.c (public) query\_npc()}

True if the living is an NPC.


\subsubsection{query\_objective}

{\em /std/living/gender.c (public) query\_objective()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_opinion}

{\em /std/living/savevars.c (public) query\_opinion()}

Returns gender code.


\subsubsection{query\_pen}

{\em /std/living/ucombat.c (public) query\_pen()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_possessive}

{\em /std/living/gender.c (public) query\_possessive()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_presentation}

{\em /std/living/description.c (public) query\_presentation()}

Function:    query\_presentation
Gives a presentation of the living in one line. Including
Name, Race, Guild titles, Alignment and Experience level
This should only be displayed to met players.


\subsubsection{query\_pronoun}

{\em /std/living/gender.c (public) query\_pronoun()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_race\_name}

{\em /std/living/savevars.c (public) query\_race\_name()}

Sorry (Will be documented later, use man -s)


\subsubsection{query\_real\_name}

{\em /std/living/description.c (public) query\_real\_name()}



\subsubsection{query\_scar}

{\em /std/living/savevars.c (public) query\_scar()}

Returns the scar bitmask


\subsubsection{query\_skill}

{\em /std/living/savevars.c (public) query\_skill(int skill)}

Gives the value of a specific skill


\subsubsection{query\_skill\_cost}

{\em /std/living/stats.c (public) query\_skill\_cost(int oldskill, int newskill)}

Skills


\subsubsection{query\_soaked}

{\em /std/living/savevars.c (public) query\_soaked()}

Sorry (Will be documented later, use man -s)


\subsubsection{query\_spellobjs}

{\em /std/living.c () query\_spellobjs()}

return the spellobj list.


\subsubsection{query\_stat}

{\em /std/living/stats.c (public) query\_stat(int stat)}

Get the compound value of a stat.

{\bf Arguments:}
\begin{itemize}
\item      stat - Which stat to find.
\end{itemize}


\subsubsection{query\_stuffed}

{\em /std/living/savevars.c (public) query\_stuffed()}

Sorry (Will be documented later, use man -s)


\subsubsection{query\_team}

{\em /std/living/combat.c (public) query\_team()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_title}

{\em /std/living/savevars.c (public) query\_title()}

Sorry (Will be documented later, use man -s)


\subsubsection{query\_total\_res}

{\em /std/living.c (public) query\_total\_res(string prop)}

Return the total resistance of worn objects

{\bf Arguments:}
\begin{itemize}
\item     prop - The searched for property.
\end{itemize}


\subsubsection{query\_weapon}

{\em /std/living/combat.c (public) query\_weapon(int which)}

Returns the weapon held in a specified location.
A list of all if illegal argument is given.

{\bf Arguments:}
\begin{itemize}
\item     which: A numeric label describing a weapon
\item location. On humanoids this is W\_RIGHT etc.
\end{itemize}

{\bf Returns:}        The corresponding weapon.


\subsubsection{query\_whimpy}

{\em /std/living/savevars.c (public) query\_whimpy()}

Sorry (Will be documented later, use man -s)


\subsubsection{query\_whimpy\_dir}

{\em /std/living/combat.c (public) query\_whimpy\_dir()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_wiz\_level}

{\em /std/living/savevars.c (public) query\_wiz\_level()}

Sorry (Will be documented later, use man -s)


\subsubsection{query\_wt}

{\em /std/living/ucombat.c (public) query\_wt()}

Obvious (Will be documented later, use man -s)


\subsubsection{reduce\_hit\_point}

{\em /std/living/savevars.c (public) reduce\_hit\_point(int dam)}

Sorry (Will be documented later, use man -s)


\subsubsection{remove\_arm}

{\em /std/living/combat.c (public) remove\_arm(object arm)}

Remove an armour

{\bf Arguments:}
\begin{itemize}
\item     arm - The armour.
\end{itemize}


\subsubsection{remove\_heart\_beat}

{\em /std/living/heart\_beat.c (public) remove\_heart\_beat(string func, object obj)}

Remove a heart\_beat function from the livings's list.

{\bf Arguments:}
\begin{itemize}
\item     func - The name of the function to call.
\item obj - The object to call the function in. 
\end{itemize}

{\bf Returns:}        1 - Ok, 0 - Not found.


\subsubsection{reset\_container}

{\em /std/living.c (public) reset\_container()}

Reset the living object. 


\subsubsection{reset\_living}

{\em /std/living.c (public) reset\_living()}

Reset the living object. (standard)


\subsubsection{run\_away}

{\em /std/living/combat.c (public) run\_away()}

Runs away from the fight


\subsubsection{savevars\_reset}

{\em /std/living/savevars.c (public) savevars\_reset()}

reset: Set all functions that are not to be shadowed


\subsubsection{set\_acc\_exp}

{\em /std/living/savevars.c () set\_acc\_exp(int stat, int val)}

Accumulated exp for each of the stats


\subsubsection{set\_al\_title}

{\em /std/living/savevars.c (public) set\_al\_title(string t)}

Sorry (Will be documented later, use man -s)


\subsubsection{set\_exp\_combat}

{\em /std/living/savevars.c (static) set\_exp\_combat(int e)}

Set how many combat xp we have.


\subsubsection{set\_fatigue}

{\em /std/living/savevars.c (public) set\_fatigue(int f)}

Sorry (Will be documented later, use man -s)


\subsubsection{set\_flag}

{\em /std/living/savevars.c (public) set\_flag(int n)}

Set a flag.

{\bf Arguments:}
\begin{itemize}
\item      n - The flag to set.
\end{itemize}

{\bf Returns:}        1 - Success, 0 - Failure


\subsubsection{set\_ghost}

{\em /std/living/savevars.c () set\_ghost(int flag)}

Ghost


\subsubsection{set\_headache}

{\em /std/living/savevars.c (public) set\_headache(int i)}

Set how much headache we have


\subsubsection{set\_hp}

{\em /std/living/savevars.c () set\_hp(int hp)}

Hitpoints.


\subsubsection{set\_intoxicated}

{\em /std/living/savevars.c (static) set\_intoxicated(int i)}

Set how intoxicated we are


\subsubsection{set\_leader}

{\em /std/living/combat.c (public) set\_leader(object leader)}

Sets this living as a member in a team
It will fail if this living is a leader itself

{\bf Arguments:}
\begin{itemize}
\item     leader: The objectpointer to the leader of the team
\end{itemize}

{\bf Returns:}    True if successfull


\subsubsection{set\_m\_out}

{\em /std/living/savevars.c (public) set\_m\_out(string m)}

Sorry (Will be documented later, use man -s)


\subsubsection{set\_mana}

{\em /std/living/savevars.c () set\_mana(int sp)}

Mana 
(Spellpoints, magic points or whatever you want to call them)


\subsubsection{set\_mm\_in}

{\em /std/living/savevars.c (public) set\_mm\_in(string m)}

Sorry (Will be documented later, use man -s)


\subsubsection{set\_mm\_out}

{\em /std/living/savevars.c (public) set\_mm\_out(string m)}

Sorry (Will be documented later, use man -s)


\subsubsection{set\_race\_name}

{\em /std/living/savevars.c (public) set\_race\_name(string str)}

Sorry (Will be documented later, use man -s)


\subsubsection{set\_scar}

{\em /std/living/savevars.c (public) set\_scar(int s)}

Set the scar bitmask


\subsubsection{set\_skill}

{\em /std/living/savevars.c () set\_skill(int skill, int val)}

Set a specific skill to a specific value

{\bf Returns:}  True is successfull, else 0. If a living has more than
a certain number of skills. He can not have more.


\subsubsection{set\_soaked}

{\em /std/living/savevars.c (static) set\_soaked(int i)}

Set how soaked we are.


\subsubsection{set\_stuffed}

{\em /std/living/savevars.c (static) set\_stuffed(int i)}

Set how stuffed we are


\subsubsection{set\_title}

{\em /std/living/savevars.c (public) set\_title(string t)}

Sorry (Will be documented later, use man -s)


\subsubsection{set\_whimpy\_dir}

{\em /std/living/combat.c (public) set\_whimpy\_dir(string str)}

Obvious (Will be documented later, use man -s)


\subsubsection{short}

{\em /std/living/description.c (public) short()}



\subsubsection{show\_scar}

{\em /std/living/description.c () show\_scar()}

Used by long()


\subsubsection{show\_wielded}

{\em /std/living/combat.c (public) show\_wielded()}

Describe the currently wielded weapons.

{\bf Returns:}        Description string.


\subsubsection{ss\_reset}

{\em /std/living/stats.c (static) ss\_reset()}

Reset stats and skills at start of character.


\subsubsection{start\_hunting}

{\em /std/living/combat.c (public) start\_hunting(object victim)}

Makes us start hunting someone

{\bf Arguments:}
\begin{itemize}
\item     victim: The one we are supposed to start hunting
\end{itemize}


\subsubsection{stat\_to\_exp}

{\em /std/living/stats.c () stat\_to\_exp(int stat)}

Translates given stat value to minimum number of experience points required.
{\bf Arguments:}
\begin{itemize}
\item exp is the number of experience points to be translated.
\end{itemize}


\subsubsection{stats\_to\_acc\_exp}

{\em /std/living/stats.c (static) stats\_to\_acc\_exp()}

Translates the current base stats into acc\_exp. This is used
only from default setup in \\ player\_sec::new\_init()


\subsubsection{stop\_fight}

{\em /std/living/combat.c (public) stop\_fight(mixed elist)}

Stops the current fight


\subsubsection{stop\_heart}

{\em /std/living/heart\_beat.c (static) stop\_heart()}

Stop the heart beat for the living object and mark
the time for later reference.


\subsubsection{stop\_hunting}

{\em /std/living/combat.c (public) stop\_hunting(object victim)}

Makes us stop hunting someone

{\bf Arguments:}
\begin{itemize}
\item     victim: The one we are supposed to stop hunting
\end{itemize}


\subsubsection{stringquery\_al\_title}

{\em /std/living/savevars.c (public) stringquery\_al\_title()}

Sorry (Will be documented later, use man -s)


\subsubsection{team\_join}

{\em /std/living/combat.c (public) team\_join(object member)}

Sets this living as the leader of another
Fails if we have a leader, then we can't lead others.

{\bf Arguments:}
\begin{itemize}
\item     member: The objectpointer to the new member of my team
\end{itemize}

{\bf Returns:}        True if member accepted in the team


\subsubsection{team\_leave}

{\em /std/living/combat.c (public) team\_leave(object member)}

Removes this living as the leader of another

{\bf Arguments:}
\begin{itemize}
\item     member: The objectpointer to the member leaving my team
\end{itemize}

{\bf Returns:}    True if successful


\subsubsection{test\_flag}

{\em /std/living/savevars.c (public) test\_flag(int n)}

Test the value of a flag.

{\bf Arguments:}
\begin{itemize}
\item      n - The flag to test.
\end{itemize}


\subsubsection{try\_hit}

{\em /std/living/ucombat.c (public) try\_hit()}

Returns false if we failed to hit.


\subsubsection{unwield}

{\em /std/living/combat.c (public) unwield(object wep)}

Unwield a weapon.

{\bf Arguments:}
\begin{itemize}
\item     wep - The weapon to unwield.
\end{itemize}

{\bf Returns:}        None.


\subsubsection{update\_acc\_exp}

{\em /std/living/stats.c (static) update\_acc\_exp()}

Fills in the acc\_exp for each stat from the total exp
depending on the learning preferences. This works the same
for reduction of acc\_exp.


\subsubsection{update\_hooks}

{\em /std/living/cmdhooks.c (public) update\_hooks()}



\subsubsection{update\_internal}

{\em /std/living.c (public) update\_internal(int l, int w, int v)}

Updates the light, weight and volume of things inside
also updates a possible environment.

{\bf Arguments:}
\begin{itemize}
\item      l: Light diff.
\item w: Weight diff.
\item v: Volume diff.
\end{itemize}


\subsubsection{voidadd\_mana}

{\em /std/living/savevars.c () voidadd\_mana(int sp)}

Mana 
(Spellpoints, magic points or whatever you want to call them)


\subsubsection{voidstop\_fight}

{\em /std/living/combat.c (public) voidstop\_fight()}

Stops the current fight


\subsubsection{weapon\_attack}

{\em /std/living/combat.c (static) weapon\_attack(object wepobj, int hitmod)}

Let the wielded weapon try to hit

{\bf Arguments:}
\begin{itemize}
\item      wepobj - The weapon.
\item hitmod - Modifier to hit.
\end{itemize}

{\bf Returns:}        True if hit else 0.


\subsubsection{wear\_arm}

{\em /std/living/combat.c (public) wear\_arm(object arm)}

Wear an armour

{\bf Arguments:}
\begin{itemize}
\item     arm - The armour.
\end{itemize}


\subsubsection{wield}

{\em /std/living/combat.c () wield(object wep)}

Wield a weapon.

{\bf Arguments:}
\begin{itemize}
\item     wep - The weapon to wield.
\end{itemize}

{\bf Returns:}        True if ok.
public int


\subsection{monster}
\subsubsection{add\_cchat}

{\em /std/monster.c () add\_cchat(string str)}

Sets a combat chat string that the monster will randomly say

{\bf Arguments:}
\begin{itemize}
\item     str: Text
\end{itemize}


\subsubsection{add\_chat}

{\em /std/monster.c () add\_chat(mixed str)}

Adds a chat string that the monster will randomly say.

{\bf Arguments:}
\begin{itemize}
\item     str: Text
\end{itemize}


\subsubsection{catch\_tell}

{\em /std/monster.c () catch\_tell(string str)}

For monster link purposes


\subsubsection{create\_monster}

{\em /std/monster.c () create\_monster()}

Create the monster. (standard)


\subsubsection{create\_npc}

{\em /std/monster.c () create\_npc()}

Create the inherited npc object. (constructor)


\subsubsection{mtrig\_follow}

{\em /std/monster.c () mtrig\_follow(string s1, string s2)}

The text trig function


\subsubsection{reset\_monster}

{\em /std/monster.c () reset\_monster()}

Reset the monster. (standard)


\subsubsection{set\_cchat\_time}

{\em /std/monster.c () set\_cchat\_time(int tim)}

Set the mean value for cchat intervall

{\bf Arguments:}
\begin{itemize}
\item     tim: Intervall
\end{itemize}


\subsubsection{set\_chat\_time}

{\em /std/monster.c () set\_chat\_time(int tim)}

Set the mean value for chat intervall

{\bf Arguments:}
\begin{itemize}
\item     tim: Intervall
\end{itemize}


\subsubsection{set\_link\_remote}

{\em /std/monster.c () set\_link\_remote(object player)}

Links a player to the output of the monster

{\bf Arguments:}
\begin{itemize}
\item     player: Player to link monster to
\end{itemize}


\subsubsection{set\_pick\_up}

{\em /std/monster.c () set\_pick\_up(int pick)}

set the ability to pick up stuff from the ground

{\bf Arguments:}
\begin{itemize}
\item     pick - Positive value: Pick up stuff.
\end{itemize}


\subsubsection{set\_random\_move}

{\em /std/monster.c () set\_random\_move(int time)}

Set the ability to walk around, and the
time affecting limit.

{\bf Arguments:}
\begin{itemize}
\item     time - The added time to the base time.
\end{itemize}


\subsubsection{voidset\_follow}

{\em /std/monster.c () voidset\_follow(string name)}

Sets the name of someone to follow

{\bf Arguments:}
\begin{itemize}
\item     name: Name of living (something that works with present() )
\end{itemize}


\subsection{npc}
\subsubsection{catch\_tell}

{\em /std/trigaction.c () catch\_tell(str)}

This is the text that normal players gets written to
their sockets.


\subsubsection{default\_config\_npc}

{\em /std/npc.c () default\_config\_npc()}

Sets all neccessary values for this npc to function


\subsubsection{seq\_addfirst}

{\em /std/seqaction.c () seq\_addfirst(name, cmd)}

Add a command or an array of commands first in a sequence


\subsubsection{seq\_addlast}

{\em /std/seqaction.c () seq\_addlast(name, cmd)}

Add a command or an array of commands last in a sequence 


\subsubsection{seq\_clear}

{\em /std/seqaction.c () seq\_clear(name)}

Clears a given sequence from commands.


\subsubsection{seq\_delete}

{\em /std/seqaction.c () seq\_delete(name)}

Delete an entire sequence


\subsubsection{seq\_heartbeat}

{\em /std/seqaction.c () seq\_heartbeat()}

The core function that actually runs the commands


\subsubsection{seq\_new}

{\em /std/seqaction.c () seq\_new(name)}

New command sequence


\subsubsection{seq\_query}

{\em /std/seqaction.c () seq\_query(name)}

Returns the sequence of commands for a given sequence


\subsubsection{seq\_query\_names}

{\em /std/seqaction.c () seq\_query\_names()}

Returns the list of sequences (their names)


\subsubsection{seq\_reset}

{\em /std/seqaction.c () seq\_reset()}

Called from living to initialize


\subsubsection{team\_join}

{\em /std/npc.c () team\_join(object member)}

Sets this living as the leader of another

{\bf Arguments:}
\begin{itemize}
\item     member: The objectpointer to the new member of my team
\end{itemize}

{\bf Returns:}        True if member accepted in the team


\subsubsection{test\_if\_any\_here}

{\em /std/npc.c () test\_if\_any\_here()}

Turn of heart\_beat if we are alone.

{\bf Returns:} 


\subsubsection{trig\_delete}

{\em /std/trigaction.c () trig\_delete(pat)}

Delete a pattern from the ones to trig on


\subsubsection{trig\_new}

{\em /std/trigaction.c () trig\_new(pat, func)}

Add a new pattern to trig on


\subsubsection{trig\_query\_args}

{\em /std/trigaction.c () trig\_query\_args()}

Query for current arguments returned from parse\_command


\subsubsection{trig\_query\_text}

{\em /std/trigaction.c () trig\_query\_text()}

Query for current catched text


\subsubsection{trig\_setobjects}

{\em /std/trigaction.c () trig\_setobjects(obs)}

Set the objects to trig on when pattern includes \%i/\%l


\subsection{object}
\subsubsection{add\_item}

{\em /std/object.c (public) add\_item(mixed names, string desc)}

Adds an additional item to the object. The first 
argument is a single string or an array of 
strings holding the possible name(s) of the item.
The second argument is the long description of 
the item. add\_item can be repeatedly called with 
new items.

{\bf Arguments:}
\begin{itemize}
\item     names: Alternate names for the item, 
\item desc: desc of the item
\end{itemize}

{\bf Returns:}    True or false.


\subsubsection{add\_noshadow}

{\em /std/object.c (static) add\_noshadow(mixed fun)}

Add a function to the ones that are nonshadowable
Obsolete, from 3.00.51 nomasked functions can't be
shadowed.


\subsubsection{add\_prop}

{\em /std/object.c (public) add\_prop(string prop, mixed val)}

Add a property to the property list
If the property already exist, the value is replaced

{\bf Arguments:}
\begin{itemize}
\item     prop - The property string to be added.
\item val: The value of the property
\end{itemize}

{\bf Returns:}        None.


\subsubsection{adjectiv\_id}

{\em /std/object.c (public) adjectiv\_id(string str)}

Identify the objects adjectives.

{\bf Arguments:}
\begin{itemize}
\item     str: String to test with.
\end{itemize}

{\bf Returns:}    True or false.


\subsubsection{change\_prop}

{\em /std/object.c (public) change\_prop(string prop, mixed val)}

Change a property value.

{\bf Arguments:}
\begin{itemize}
\item     prop - The property string to be changed.
\item val: The value of the property
\end{itemize}

{\bf Returns:}        None.


\subsubsection{check\_call}

{\em /std/object.c (public) check\_call(string retval)}

Fixes a call to a named function if the value is on the form:
'@@function[:filename][|arg|arg]@@' Filename is optional

{\bf Arguments:}
\begin{itemize}
\item      retval: The value to be returned immidiatelly or a function
\item description.
\end{itemize}


\subsubsection{create}

{\em /std/object.c (public) create()}

Object constructor, called directly after load / clone


\subsubsection{create\_object}

{\em /std/object.c (public) create\_object()}

Create the object (Default for clones)


\subsubsection{del\_list}

{\em /std/object.c (static) del\_list(mixed list\_old, mixed list\_del)}

Removes one or many elements from a list.

{\bf Arguments:}
\begin{itemize}
\item     list\_old: The list as it looks.
\item list\_del: What should be deleted
\end{itemize}

{\bf Returns:}    The new list.


\subsubsection{enter\_inv}

{\em /std/object.c () enter\_inv(object dest, object old)}

Default movedetect functions


\subsubsection{exist\_prop}

{\em /std/object.c (public) exist\_prop(string prop)}

Search for a property or return the entire list.

{\bf Arguments:}
\begin{itemize}
\item     prop - The property searched for.
\end{itemize}

{\bf Returns:}        1/0 or the list.


\subsubsection{id}

{\em /std/object.c (public) id(string str)}

Identify the object.

{\bf Arguments:}
\begin{itemize}
\item     str: String to test with.
\end{itemize}

{\bf Returns:}    True or false.


\subsubsection{long}

{\em /std/object.c (public) long(string str)}

Describe the object or one item (pseudo look) in it
{\em NOTE! This lfun does not do a write() !!}

{\bf Arguments:}
\begin{itemize}
\item     str: name of item or 0
\end{itemize}

{\bf Returns:}    Description of object in a string.


\subsubsection{mixedcheck\_call}

{\em /std/object.c (public) mixedcheck\_call(string retval)}

Fixes a call to a named function if the value is on the form:
'@@function[:filename][|arg|arg]@@' Filename is optional

{\bf Arguments:}
\begin{itemize}
\item      retval: The value to be returned immidiatelly or a function
\item description.
\end{itemize}


\subsubsection{move}

{\em /std/object.c (public) move(mixed dest, mixed subloc)}

Move this object to the destination given by string /
obj. If the second parameter exists then weight
accounting and tests on destination is not done.

{\bf Arguments:}
\begin{itemize}
\item     dest: Object or filename to move to,
\item subloc: 1 == Always move, otherwise name of sublocation
\end{itemize}

{\bf Returns:}        Result code of move:
                  0: Success.
\subsubsection{move}

{\em  To heavy for destination.}

\subsubsection{move}

{\em  Can't be dropped.}

\subsubsection{move}

{\em  Can't take it out of it's container.}

\subsubsection{move}

{\em  The object can't be inserted into bags etc.}

\subsubsection{move}

{\em  The destination doesn't allow insertions of objects.}

\subsubsection{move}

{\em  The object can't be picked up.}

\subsubsection{move}

{\em  Other (Error message printed inside move() func)}

\subsubsection{move}

{\em  To big volume for destination}



\subsubsection{notify\_change\_prop}

{\em /std/object.c (public) notify\_change\_prop(string prop, mixed val, mixed oval)}

This function is called when a property in an object
in the inventory has been changed.

{\bf Arguments:}
\begin{itemize}
\item     prop - The property that has been changed.
\item val  - The new value.
\item oval - The old value
\end{itemize}


\subsubsection{parse\_command\_id\_list}

{\em /std/object.c (public) parse\_command\_id\_list()}

PARSE\_COMMAND
These lfuns are called from within the efun parse\_command() to get the
three different sets of ids. If no plural ids are returned then the
efun will try to make pluralforms from the singular ids.
If no normal ids are returned then parse\_command will never find the object.


\subsubsection{plural\_id}

{\em /std/object.c (public) plural\_id(string str)}

Identify the object.

{\bf Arguments:}
\begin{itemize}
\item     str: String to test with in plural form.
\end{itemize}

{\bf Returns:}    True or false.


\subsubsection{plural\_short}

{\em /std/object.c (public) plural\_short()}

Return the plural short description of the object.


\subsubsection{query\_item}

{\em /std/object.c (public) query\_item()}

Get the additional items array.

{\bf Returns:}    Item array, see below:

\begin{verbatim}
  [0] = array
     [0] (\{ "name1 of item1", "name2 of item1",... \})
     [1] "This is the description of the item1."
  [1] = array
     [0] (\{ "name1 of item2", "name2 of item2", ... \})
     [1] "This is the description of the item2."
\end{verbatim}

\subsubsection{query\_list}

{\em /std/object.c (static) query\_list(mixed list,int arg)}

Gives the return of a query on a list.

{\bf Arguments:}
\begin{itemize}
\item     list: The list in question
\item arg: If true then the entire list is returned.
\end{itemize}

{\bf Returns:}        A string or an array as described above.


\subsubsection{query\_lock}

{\em /std/object.c (public) query\_lock()}

Gives the lock status of this object

{\bf Returns:}        True if changes to this object is locked out


\subsubsection{query\_long}

{\em /std/object.c (public) query\_long()}

Gives the set long description

{\bf Returns:}        Exactly what was given to set\_long()


\subsubsection{query\_no\_show}

{\em /std/object.c (public) query\_no\_show()}

Return no show status.


\subsubsection{query\_noshadow}

{\em /std/object.c (public) query\_noshadow()}

Returns a list of all functions that are nonshadowable
Obsolete, from 3.00.51 nomasked functions can't be
shadowed.


\subsubsection{query\_plural\_short}

{\em /std/object.c (public) query\_plural\_short()}

Gives the set plural\_short description

{\bf Returns:}        Exactly what was given to set\_plural\_short()


\subsubsection{query\_prevent\_shadow}

{\em /std/object.c (public) query\_prevent\_shadow(object ob)}

Checks if an object is allowed to shadow this object.


\subsubsection{query\_prop}

{\em /std/object.c (public) query\_prop(string prop)}

Find the value of a property.

{\bf Arguments:}
\begin{itemize}
\item     prop - The property searched for.
\end{itemize}

{\bf Returns:}        The value or 0.


\subsubsection{query\_short}

{\em /std/object.c (public) query\_short()}

Gives the set short description

{\bf Returns:}        Exactly what was given to set\_short()


\subsubsection{query\_subloc}

{\em /std/object.c () query\_subloc()}

Get the current sub location's name


\subsubsection{remove\_adj}

{\em /std/object.c (public) remove\_adj(mixed adj)}

Removes one adjective

{\bf Arguments:}
\begin{itemize}
\item     adj: string of one adjective or an array of adjectives
\end{itemize}


\subsubsection{remove\_item}

{\em /std/object.c (public) remove\_item(string name)}

Removes one additional item from the additional item list
{\bf Arguments:}
\begin{itemize}
\item     name: name of item to remove.
\end{itemize}

{\bf Returns:}    True or false. (True if removed successfully)


\subsubsection{remove\_name}

{\em /std/object.c (public) remove\_name(mixed name)}

Removes one name

{\bf Arguments:}
\begin{itemize}
\item     name: string of one name or an array of names
\end{itemize}


\subsubsection{remove\_object}

{\em /std/object.c (public) remove\_object()}

Removes this object from the game.

{\bf Returns:}        True if the object was removed.


\subsubsection{remove\_pname}

{\em /std/object.c (public) remove\_pname(mixed pname)}

Removes one pname

{\bf Arguments:}
\begin{itemize}
\item     pname: string of one pname or an array of pnames
\end{itemize}


\subsubsection{remove\_prop}

{\em /std/object.c (public) remove\_prop(string prop)}

Removes a property string from the property list.

{\bf Arguments:}
\begin{itemize}
\item     prop - The property string to be removed.
\end{itemize}

{\bf Returns:}        1 / 0.


\subsubsection{reset}

{\em /std/object.c (public) reset()}

Reset the object (always called, used as constructor)

{\bf Arguments:}
\begin{itemize}
\item     arg: The reset argument.
\end{itemize}


\subsubsection{reset\_object}

{\em /std/object.c (public) reset\_object()}

Reset the object (Default for clones)


\subsubsection{set\_adj}

{\em /std/object.c (public) set\_adj(mixed adj)}

Sets the accepatble adjective(s) of the object.
This is used as a complement to name in refering to the
object. It is also used when refering to nondescript objects
like for example: "get all the red ones"
If not defined then all but last word of short() is used.

{\bf Arguments:}
\begin{itemize}
\item     adj: string of one adjective or array of strings of
\item adjectives
\end{itemize}


\subsubsection{set\_lock}

{\em /std/object.c (public) set\_lock()}

Locks out all changes to this object through set\_ functions.


\subsubsection{set\_long}

{\em /std/object.c (public) set\_long(string long)}

Sets the string to write as a long description.
If not defined, the short() is used instead.

{\bf Arguments:}
\begin{itemize}
\item      long: The long description
\end{itemize}


\subsubsection{set\_name}

{\em /std/object.c (public) set\_name(string name)}

Sets the name(s) of the object. This is the name that
the object can be referenced by. set\_name can be called
repeatedly to add more names.

{\bf Arguments:}
\begin{itemize}
\item     name: string holding one name.
\end{itemize}


\subsubsection{set\_no\_show}

{\em /std/object.c (public) set\_no\_show()}

Don't show these objects.


\subsubsection{set\_pname}

{\em /std/object.c (public) set\_pname(string pname)}

Sets the pluralform of the name(s) of the object. This is
used when refering to the object in plural. If not defined
then the singular form is used. set\_pname can be called
repeatedly to add more pluralforms for names.

{\bf Arguments:}
\begin{itemize}
\item     name: string holding one name.
\end{itemize}


\subsubsection{set\_pshort}

{\em /std/object.c (public) set\_pshort(string pshort)}

Sets the string to return for plural short description.
If not defined, 0 is returned.

{\bf Arguments:}
\begin{itemize}
\item      pshort: The plural short description
\end{itemize}


\subsubsection{set\_short}

{\em /std/object.c (public) set\_short(string short)}

Sets the string to return for short description.
If not defined, the first name is used instead.

{\bf Arguments:}
\begin{itemize}
\item      short: The short description
\end{itemize}


\subsubsection{set\_trusted}

{\em /std/object.c (public) set\_trusted(int arg)}

Sets the effuserid to the userid of this object. This is
used by the 'trust' command mainly on wiztools.

{\bf Arguments:}
\begin{itemize}
\item     arg - 1 = set the euid of this object.
\item 0 = remove the euid.
\end{itemize}


\subsubsection{short}

{\em /std/object.c (public) short()}

Return the short description of the object.


\subsection{player\_sec}
\subsubsection{add\_introduced}

{\em /std/player/getmsg\_sec.c (public) add\_introduced(string str)}

Adds a living to those whom we are introduced to.

{\bf Arguments:}
\begin{itemize}
\item      str: Name of living that introduced itself
\end{itemize}


\subsubsection{add\_queue}

{\em /std/player/querys\_sec.c (public) add\_queue(string who)}

Add a player to a queue.
Return:   Number of people in the queue after addition.


\subsubsection{catch\_msg}

{\em /std/player/getmsg\_sec.c (public) catch\_msg(mixed str, object from\_player)}

This function is called for every normal message sent
to this player. The only exception is efun tell\_object()

{\bf Arguments:}
\begin{itemize}
\item      msg:       Message to tell the player
\item from\_player: The object that generated the message
\item This is only valid if the message is on the
\item form (\{ "met message", "unmet message" \})
\end{itemize}


\subsubsection{command}

{\em /std/player\_sec.c (public) command(string cmd)}

Makes the player execute a command, If the player is a
wizard then the object must have the same effective
userid as the wizard being forced.

{\bf Arguments:}
\begin{itemize}
\item       cmd: String containing the command
\end{itemize}

{\bf Returns:}      eval\_cost or '0' if unsuccessful


\subsubsection{compute\_auto\_str}

{\em /std/player/cmd\_sec.c (static) compute\_auto\_str()}

Array of autoload strings on the form: 'file:argument'


\subsubsection{compute\_values}

{\em /std/player/cmd\_sec.c (public) compute\_values(object *ob\_list)}

Recursively compute the values of the inventory.
Beware that object may selfdestruct when asked for query\_value().


\subsubsection{desc\_scar}

{\em /std/player/death\_sec.c (public) desc\_scar()}

Get the composite string holding the scar description

{\bf Returns:}        string holding scar description.


\subsubsection{enter\_game}

{\em /std/player\_sec.c (public) enter\_game(string pl\_name)}

Enter the player into the game

{\bf Arguments:}
\begin{itemize}
\item     pl\_name: Name of the player
\item Security:
\item This function must only be called from "/secure/login"
\end{itemize}


\subsubsection{intquery\_login\_time}

{\em /std/player/savevars\_sec.c (public) intquery\_login\_time()}

Obvious (Will be documented later, use man -s)


\subsubsection{load\_auto\_obj}

{\em /std/player\_sec.c (static) load\_auto\_obj(string *load\_arr)}

Loads all autoloaded objects


\subsubsection{load\_auto\_shadow}

{\em /std/player\_sec.c (static) load\_auto\_shadow(string *load\_arr)}

Startup all the shadows that should shadow this player


\subsubsection{login\_set\_password}

{\em /std/player/savevars\_sec.c () login\_set\_password(string p)}

Password


\subsubsection{long}

{\em /std/player/getmsg\_sec.c (public) long()}

Obvious (Will be documented later, use man -s)


\subsubsection{make\_scar}

{\em /std/player/death\_sec.c (static) make\_scar()}

Obvious (Will be documented later, use man -s)


\subsubsection{master\_set\_name}

{\em /std/player/savevars\_sec.c () master\_set\_name(string n)}

Name of the living object.
/secure/master needs to be able to do set\_name


\subsubsection{modify\_stats}

{\em /std/player/death\_sec.c (static) modify\_stats()}

Obvious (Will be documented later, use man -s)


\subsubsection{new\_init}

{\em /std/player\_sec.c (static) new\_init()}

Function:     new\_init
Initialises all variables to default conditions.


\subsubsection{new\_save}

{\em /std/player\_sec.c (public) new\_save(string pl\_name, string pwd, string pfile)}

Save this player as 'name'
This is only called from /secure/login when new players
enters the game. It makes it possible to initialize variables
using the standard set\_ calls.

{\bf Arguments:}
\begin{itemize}
\item     pl\_name: Name of the player
\item Security:
\item This function must only be called from "/secure/login"
\end{itemize}


\subsubsection{num\_scar}

{\em /std/player/death\_sec.c (public) num\_scar()}

Get the number of scars a player has

{\bf Returns:}        int holding number of scars


\subsubsection{pop\_queue}

{\em /std/player/querys\_sec.c (public) pop\_queue(string who)}

Return the queue list.


\subsubsection{query\_al\_title}

{\em /std/player/savevars\_sec.c (public) query\_al\_title()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_auto\_load}

{\em /std/player/savevars\_sec.c () query\_auto\_load()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_autoshadow\_list}

{\em /std/player/savevars\_sec.c (public) query\_autoshadow\_list()}

Return the autoshadow list.


\subsubsection{query\_brief}

{\em /std/player/savevars\_sec.c (public) query\_brief()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_cap\_name}

{\em /std/player/savevars\_sec.c (public) query\_cap\_name()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_cmdsoul\_list}

{\em /std/player/savevars\_sec.c (public) query\_cmdsoul\_list()}

Return the command soul list.


\subsubsection{query\_def\_start}

{\em /std/player\_sec.c (public) query\_def\_start()}

Return the default starting location of the player type
This function is supposed to be replaced in inheriting
player objects.


\subsubsection{query\_default\_start\_location}

{\em /std/player/savevars\_sec.c (public) query\_default\_start\_location()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_domain}

{\em /std/player/savevars\_sec.c (public) query\_domain()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_introduced}

{\em /std/player/getmsg\_sec.c (public) query\_introduced()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_invited}

{\em /std/player/pcombat.c (public) query\_invited()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_login\_from}

{\em /std/player/savevars\_sec.c (public) query\_login\_from()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_login\_time}

{\em /std/player/savevars\_sec.c (public) query\_login\_time()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_mailaddr}

{\em /std/player/savevars\_sec.c (public) query\_mailaddr()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_met}

{\em /std/player/getmsg\_sec.c (public) query\_met(mixed name)}

Tells if we know a certain living's name.

{\bf Arguments:}
\begin{itemize}
\item      name: Name of living or objectp of living
\end{itemize}

{\bf Returns:}        True if we know this name otherwise false.


\subsubsection{query\_new\_al\_title}

{\em /std/player\_sec.c (public) query\_new\_al\_title()}

Return the default starting title of a player
This function is supposed to be replaced in inheriting
player objects.


\subsubsection{query\_new\_title}

{\em /std/player\_sec.c (public) query\_new\_title()}

Return the default starting title of a player
This function is supposed to be replaced in inheriting
player objects.


\subsubsection{query\_orig\_learn}

{\em /std/player\_sec.c (public) query\_orig\_learn()}

Return the default starting stats of a player
This function is supposed to be replaced in inheriting
player objects.


\subsubsection{query\_orig\_stat}

{\em /std/player\_sec.c (public) query\_orig\_stat()}

Return the default starting stats of a player
This function is supposed to be replaced in inheriting
player objects.


\subsubsection{query\_path}

{\em /std/player/savevars\_sec.c (public) query\_path()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_player\_file}

{\em /std/player/savevars\_sec.c (public) query\_player\_file()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_presentation}

{\em /std/player/querys\_sec.c (public) query\_presentation()}

Function:    query\_presentation
Gives a presentation of the living in one line. Including
Name, Race, Guild titles, Alignment and Experience level
This should only be displayed to met players.


\subsubsection{query\_prevent\_shadow}

{\em /std/player\_sec.c (public) query\_prevent\_shadow()}

For the time being, until we have a shadow that do not mask 
functions declared 'nomask'


\subsubsection{query\_queue\_list}

{\em /std/player/querys\_sec.c (public) query\_queue\_list()}

Return the queue list.


\subsubsection{query\_real\_name}

{\em /std/player/savevars\_sec.c (public) query\_real\_name()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_remember\_name}

{\em /std/player/savevars\_sec.c (public) query\_remember\_name()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_remembered}

{\em /std/player/getmsg\_sec.c (public) query\_remembered()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_sanctioned}

{\em /std/player/savevars\_sec.c (public) query\_sanctioned()}

Return the 'sanctioned' field in the player.


\subsubsection{query\_sanctioning}

{\em /std/player/savevars\_sec.c (public) query\_sanctioning(string s\_taker)}

Return a player's sanctioning, if any
s\_taker - The sanctioned


\subsubsection{query\_scar}

{\em /std/player/savevars\_sec.c (public) query\_scar()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_temp\_start\_location}

{\em /std/player/savevars\_sec.c (public) query\_temp\_start\_location()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_title}

{\em /std/player/savevars\_sec.c (public) query\_title()}

Obvious (Will be documented later, use man -s)


\subsubsection{query\_tool\_list}

{\em /std/player/savevars\_sec.c (public) query\_tool\_list()}

Return the tool soul list.


\subsubsection{query\_tot\_value}

{\em /std/player/savevars\_sec.c (public) query\_tot\_value()}

Obvious (Will be documented later, use man -s)


\subsubsection{remove\_adj}

{\em /std/player/savevars\_sec.c (public) remove\_adj(string str)}

'go through function' for storing the adjectives


\subsubsection{remove\_autoshadow}

{\em /std/player/savevars\_sec.c (public) remove\_autoshadow(mixed shadowfile)}

Remove a shadow from the shadow list


\subsubsection{remove\_cmdsoul}

{\em /std/player/savevars\_sec.c (public) remove\_cmdsoul(string soul)}

Remove a command soul from the list.


\subsubsection{remove\_ghost}

{\em /std/player/death\_sec.c (public) remove\_ghost()}

Obvious (Will be documented later, use man -s)


\subsubsection{remove\_toolsoul}

{\em /std/player/savevars\_sec.c (public) remove\_toolsoul(string soul)}

Remove a tool soul from the list.


\subsubsection{save\_character}

{\em /std/player/cmd\_sec.c (public) save\_character()}

Obvious (Will be documented later, use man -s)


\subsubsection{save\_me}

{\em /std/player/cmd\_sec.c (public) save\_me(int value\_items)}

Obvious (Will be documented later, use man -s)


\subsubsection{second\_life}

{\em /std/player/death\_sec.c (public) second\_life(object killer\_object)}

Handles all that should happen to a dying player.
Argument:      Object that caused the kill.

{\bf Returns:}        True if the living object should get a second life


\subsubsection{set\_adj}

{\em /std/player/savevars\_sec.c (public) set\_adj(string *arr)}

'go through function' for storing the adjectives. Also
sets the adjectives to 'adj\_desc' if no arg given.
No more than 2 adjectives of a total length of 35
characters is allowed.
Argument:       str: Adjectives to pass to ::set\_adj() or 0.


\subsubsection{set\_al\_title}

{\em /std/player/savevars\_sec.c (public) set\_al\_title(string t)}

Obvious (Will be documented later, use man -s)


\subsubsection{set\_cap\_name}

{\em /std/player/savevars\_sec.c (public) set\_cap\_name()}

Obvious (Will be documented later, use man -s)


\subsubsection{set\_domain}

{\em /std/player/savevars\_sec.c (public) set\_domain(string dom)}

Obvious (Will be documented later, use man -s)


\subsubsection{set\_name}

{\em /std/player/savevars\_sec.c () set\_name(string n)}

Name of the player.
This can only be called from player\_sec.


\subsubsection{set\_path}

{\em /std/player/savevars\_sec.c (public) set\_path(string str)}

Obvious (Will be documented later, use man -s)


\subsubsection{set\_player\_file}

{\em /std/player/savevars\_sec.c () set\_player\_file(string f)}

Obvious (Will be documented later, use man -s)


\subsubsection{set\_remember\_name}

{\em /std/player/savevars\_sec.c (public) set\_remember\_name(string *nlist)}

Obvious (Will be documented later, use man -s)


\subsubsection{set\_scar}

{\em /std/player/savevars\_sec.c (public) set\_scar(int s)}

Obvious (Will be documented later, use man -s)


\subsubsection{set\_title}

{\em /std/player/savevars\_sec.c (public) set\_title(string t)}

Obvious (Will be documented later, use man -s)


\subsubsection{short}

{\em /std/player\_sec.c (public) short()}

Functions that have to be redirected to the right inherited module


\subsubsection{show\_scar}

{\em /std/player/getmsg\_sec.c () show\_scar()}

Used by long()


\subsubsection{team\_invite}

{\em /std/player/pcombat.c (public) team\_invite(object member)}

Invites a new member to my team. This does NOT join the
member to my team. It only makes it possible for the player
to join my team.

{\bf Arguments:}
\begin{itemize}
\item     member: The objectpointer to the invited member.
\item If member == 0, the invited list is cleared.
\end{itemize}


\subsubsection{team\_join}

{\em /std/player/pcombat.c (public) team\_join(object member)}

Sets this player as the leader of another
Fails if 'member' not invited.

{\bf Arguments:}
\begin{itemize}
\item     member: The objectpointer to the new member of my team
\end{itemize}

{\bf Returns:}        True if member accepted in the team


\subsubsection{toggle\_brief}

{\em /std/player/cmd\_sec.c (public) toggle\_brief()}

Obvious (Will be documented later, use man -s)


\subsection{room}
\subsubsection{USAGE}

{\em /std/room.c (public) USAGE()}

Typical usage of /std/room.c

\begin{verbatim}
      inherit "/std/room";

      create_room()
      {
      set_short("A little room.");
      set_long("This is a little but very nice room.\n");
      add_exit("/room/church" , "north", 0);
      add_exit("/room/post" , "post", "@@exitfun");
      }
      exitfun(to_dest)
      {
      return (random(10)<3); /* 30\% chance not to move */
      }
\end{verbatim}

\subsubsection{add\_exit}

{\em /std/room/exits.c (public) add\_exit(string place, string cmd, mixed efunc)}

Add one exit to the room. (see also unq\_move)

{\bf Arguments:}
\begin{itemize}
\item     place: The filename of the room to move to
\item cmd:   The command given to move
\item efunc: The delay value often given by 'value by function
\item call'. The delayvalues are:
\item 0: Direct move to destination
\item =1: Can not move in this dir, do not try others
\item \verb+>+1: Can not move to destination, but try the rest
\item \verb+<+0: Move is done with delay (see link\_room)
\end{itemize}


\subsubsection{add\_my\_desc}

{\em /std/room/description.c (public) add\_my\_desc(string str, object cobj)}

Add a description printed after the normal
longdescription.

{\bf Arguments:}
\begin{itemize}
\item       str: Description as a string
\item cobj: Object responsible for the description
\item Default: previous\_object()
\end{itemize}


\subsubsection{clean\_up}

{\em /std/room.c (public) clean\_up()}

This function destruct the room if there is nothing in it.
If you have special variables stored in a room you should
define your own clean\_up(). Also if you on startup of the
room clone some objects and put inside it, please define
your own clean\_up() to destruct the room. This saves a
lot of memory in the game.


\subsubsection{create\_container}

{\em /std/room.c () create\_container()}

Create the room


\subsubsection{create\_room}

{\em /std/room.c (public) create\_room()}

Default constructor


\subsubsection{init}

{\em /std/room/exits.c (public) init()}

Add direction commands to livings in the room


\subsubsection{light}

{\em /std/room.c (static) light()}

Returns the light status in this room
This function is called from query\_prop() only.

{\bf Returns:}    Light value


\subsubsection{link\_room}

{\em /std/room/link.c (public) link\_room(string lfile, mixed dest)}

Create a corridor room. Set the descriptions of it.
Does not add exits. This is supposed to be replaced by 
the actual room inheriting this standard room. It is supposed
to set proper descriptions (long and short) instead of
copying the endpoint description. Corridor rooms are
created when the delay value in the third parameter to
add\_exit() is a negative integer. Length of corridor is
the absolute value of the delay parameter.

{\bf Arguments:}
\begin{itemize}
\item     lfile: Suggested filename to clone to get a corridor room.
\item dest:  The other endpoint of the corridor.
\end{itemize}

{\bf Returns:}        Objectpointer of the cloned room.


\subsubsection{long}

{\em /std/room/description.c (public) long(string str)}

Describe the room and possibly the exits

{\bf Arguments:}
\begin{itemize}
\item     str: name of item or 0
\end{itemize}

{\bf Returns:}        A string holding the long description of the room.


\subsubsection{make\_link}

{\em /std/room/link.c (public) make\_link(mixed to\_room, object via\_link)}

Find or make the return link. Called from other endpoint
when linking a corridor between itself and this room.

{\bf Arguments:}
\begin{itemize}
\item     to\_room:  File name of other endpoint
\item via\_link: Objectp to nearest cloned room in corridor.
\end{itemize}

{\bf Returns:}        command used to move to other endpoint from this room.


\subsubsection{map}

{\em /std/room/map.c (public) map(mixed xyc)}

Returns a filename for a given coordinate on the map.
This is always a master file, never cloned instances.
New rooms are actually created with write\_file so as to
know which rooms are there to go to.
This function is used as 'value by function call' parameter in

\begin{verbatim}
           add_exit: add_exit("@@map|xnnnn.mmynnnn.mm","north",0);
\end{verbatim}

{\bf Arguments:}
\begin{itemize}
\item        xyc: World coordinates "xnnnn.mmynnnn.mm"
\end{itemize}

{\bf Returns:}          Filename


\subsubsection{query\_desc}

{\em /std/room/description.c (public) query\_desc()}

Gives a list of all added descriptions to this room

{\bf Returns:}          Array on the form:
desc1, obj1, desc2, obj2, ..... descN, objN


\subsubsection{query\_dircmd}

{\em /std/room/move.c (public) query\_dircmd()}

Gives the rest of the command given after move verb.
This can be used in blocking functions (third arg add\_exit)

{\bf Returns:}        The movecommand as given. 


\subsubsection{query\_exit}

{\em /std/room/exits.c (public) query\_exit()}

Gives a list of the possible exits from this room.

{\bf Returns:}        An array on the form below (example):
({
"/room/church", "north" , "@@exitfun" ,
"/room/post", "post" , "@@exitfun" ,
})


\subsubsection{remove\_exit}

{\em /std/room/exits.c (public) remove\_exit(string cmd)}

Remove one exit from the room.

{\bf Arguments:}
\begin{itemize}
\item     cmd:   The command given to move in the exit to be removed
\end{itemize}


\subsubsection{remove\_my\_desc}

{\em /std/room/description.c (public) remove\_my\_desc(object cobj)}

Removes an earlier added  description printed after
the normal longdescription.

{\bf Arguments:}
\begin{itemize}
\item       cobj: Object responsible for the description
\item Default: previous\_object()
\end{itemize}


\subsubsection{set\_container}

{\em /std/room.c (public) set\_container(object ob)}

Sets the container for which the room represents the inside

{\bf Arguments:}
\begin{itemize}
\item     ob: The container object
\end{itemize}


\subsubsection{this\_room}

{\em /std/room.c (public) this\_room()}

Obvious (Will be documented later, use man -s)


\subsubsection{transport\_to}

{\em /std/room/link.c (public) transport\_to(string ex, mixed room, int delay)}

Transport player to first linked room in clone chain.  
Also creates the corridor and links it to the other
endpoint if the corridor does not exist.

{\bf Arguments:}
\begin{itemize}
\item     ex:    The direction command (north, south ...)
\item room:  The destination objectp or stringp
\item delay: The length of the cloned corridor.
\end{itemize}

{\bf Returns:}        True if player moved to first pos in corridor.
False if corridor could not be created.


\subsubsection{unq\_no\_move}

{\em /std/room/move.c (public) unq\_no\_move()}

Obvious (Will be documented later, use man -s) 


\subsubsection{update\_internal}

{\em /std/room.c (public) update\_internal(int l, int w, int v)}

Updates the light, weight and volume of things inside
also updates a possible environment.

{\bf Arguments:}
\begin{itemize}
\item      l: Light diff.
\item w: Weight diff. (Ignored)
\item v: Volume diff. (Ignored)
\end{itemize}


\subsubsection{update\_light}

{\em /std/room.c (public) update\_light()}

Reevalueate the lightvalue of the room.


\subsection{simul\_efun}
\subsubsection{add\_verb}

{\em /std/simul\_efun.c (static) add\_verb()}

add\_verb is obsolete and should no longer be used


\subsubsection{add\_xverb}

{\em /std/simul\_efun.c (static) add\_xverb()}

add\_xverb is a horrible American creation and should never ever be used


\subsubsection{all\_environment}

{\em /std/simul\_efun.c (static) all\_environment(object ob)}

Gives an array of all containers which an object is in, i.e.
match in matchbox in bigbox in chest in room, would for the
match give: matchbox, bigbox, chest, room

{\bf Arguments:}
\begin{itemize}
\item      ob: The object
\end{itemize}

{\bf Returns:}        The array of containers.


\subsubsection{break\_string}

{\em /std/simul\_efun.c (static) break\_string(string str, int width, int indent)}

Breaks a continous string without newlines into a string
with newlines inserted at regular intervalls replacing spaces
Each newline separeted string can be indented with a given
number of spaces.

{\bf Arguments:}
\begin{itemize}
\item      str: Original message
\item width: The total maximum width of each line.
\item indent: (optional) How many spaces to indent with.
\end{itemize}

{\bf Returns:}        A string with newline separated strings


\subsubsection{deep\_inventory}

{\em /std/simul\_efun.c (static) deep\_inventory(object ob)}

Gives an array of all object somewhere in a container,
including objects within containers in the container,
recursively.

{\bf Arguments:}
\begin{itemize}
\item      ob: The container object
\end{itemize}

{\bf Returns:}        An array of objects.


\subsubsection{dump\_array}

{\em /std/simul\_efun.c (static) dump\_array(mixed a, string tab)}

Dumps a variable with write() for debugging purposes.

{\bf Arguments:}
\begin{itemize}
\item      a: Anything including an array
\end{itemize}


\subsubsection{exclude\_array}

{\em /std/simul\_efun.c () exclude\_array(mixed arr, int from, int to)}

Deletes a section of an array

{\bf Arguments:}
\begin{itemize}
\item      arr: The array
\item from: Index from which to delete elements
\item to: Last index to be deleted.
\end{itemize}

{\bf Returns:} 


\subsubsection{log\_file}

{\em /std/simul\_efun.c (static) log\_file(string file, string text)}

Logs a message in the creators \verb+~+/log/ subdir in a given
file.

{\bf Arguments:}
\begin{itemize}
\item      file: The filename.
\item text: The text to add to the file
\end{itemize}


\subsubsection{ls}

{\em /std/simul\_efun.c (static) ls(string path)}

Lists files in a directory

{\bf Arguments:}
\begin{itemize}
\item      path: The filepath
\end{itemize}


\subsubsection{next\_inventory}

{\em /std/simul\_efun.c (static) next\_inventory()}

next\_inventory will be deleted, use all\_inventory or inventory


\subsubsection{query\_xverb}

{\em /std/simul\_efun.c (static) query\_xverb()}

query\_xverb should return the part of the verb that had to be filled in
when an add\_action("xxx", "yyyyy", 1) was executed.
Until we get a GD implementation it will simply return query\_verb().


\subsubsection{say}

{\em /std/simul\_efun.c (static) say(mixed str, mixed oblist)}

Tells all living objects in the same room as this\_player()
a possibly reciever dependant message.

{\bf Arguments:}
\begin{itemize}
\item      str: Either a single string containing 'value by function
\item call' expressions, such a string is sent to catch\_msg()
\item in the recieving objects.
\item If str is an array then this\_player() will be used 
\item in each recieving object to decide on met/nonmet.
\item oblist: Nothing, an object or an array of objects not
\item to send str to.
\end{itemize}


\subsubsection{setuid}

{\em /std/simul\_efun.c (static) setuid()}

Sets the userid of this object to the creator of this object.


\subsubsection{sort\_array}

{\em /std/simul\_efun.c (static) sort\_array(mixed arr, string lfunc, object obj)}

Sorts the elements of an array

{\bf Arguments:}
\begin{itemize}
\item       arr: The array to be sorted
\item lfunc: (optional) Function taking two arguments
\item and returns true if arg1 \verb+<+= arg2
\item Default: Compare arguments directly with op: \verb+<+=
\item obj: (optional) Object defining above function.
\item Default: this\_object()
\end{itemize}


\subsubsection{this\_interactive}

{\em /std/simul\_efun.c () this\_interactive()}

Gives the interactive user which is the source of this
execution chain, or 0 if we are in heart\_beat or call\_out.

{\bf Returns:}    object pointer to player or '0'


\subsubsection{update\_actions}

{\em /std/simul\_efun.c (static) update\_actions()}

Updates this\_objects actions in all living objects


\subsection{std}
\subsection{weapon}
\subsubsection{check\_weapon}

{\em /std/weapon.c () check\_weapon()}



\subsubsection{comp\_value}

{\em /std/weapon.c () comp\_value(wc)}

Compute the base cost of the weapon.

{\bf Arguments:}
\begin{itemize}
\item     wc - The weapon class.
\end{itemize}

{\bf Returns:}        The cost.


\subsubsection{create\_object}

{\em /std/weapon.c (public) create\_object(arg)}

Create the weapon. (constructor)


\subsubsection{create\_weapon}

{\em /std/weapon.c (public) create\_weapon()}

create the weapon. (standard)


\subsubsection{did\_hit}

{\em /std/weapon.c () did\_hit(int aid, string hdesc, int phurt, object enemy)}

Tells us that we hit something. Should produce combat
messages to all relevant parties. If the weapon
chooses not to handle combat messages then a default
message is generated.

{\bf Arguments:}
\begin{itemize}
\item      aid:   The attack id
\item hdesc: The hitlocation description.
\item phurt: The \%hurt made on the enemy
\item enemy: The enemy who got hit
\end{itemize}

{\bf Returns:}        True if it handled combat messages.


\subsubsection{init}

{\em /std/weapon.c () init()}

Initialize some weapon related actions.


\subsubsection{leave\_env}

{\em /std/weapon.c () leave\_env(from)}

The weapon is moved from the inventory

{\bf Arguments:}
\begin{itemize}
\item     from - Where from
\end{itemize}


\subsubsection{reset\_object}

{\em /std/weapon.c (public) reset\_object()}

Reset the weapon. 


\subsubsection{set\_default\_weapon}

{\em /std/weapon.c () set\_default\_weapon(hit, pen, wt, dt, hands, obj)}

Configures the weapon

{\bf Arguments:}
{\bf Returns:} 


\subsubsection{set\_name}

{\em /std/weapon.c () set\_name(name)}

Define set/query functions for the ordinary variables in an object


\subsubsection{short}

{\em /std/weapon.c () short()}

Return the short description of the weapon.


\subsubsection{try\_hit}

{\em /std/weapon.c () try\_hit(target)}

Called from living when weapon used.

{\bf Arguments:}
\begin{itemize}
\item      target - Who I intend to hit.
\end{itemize}

{\bf Returns:}        False if weapon miss. If true it might hit.


\subsubsection{unwield\_me}

{\em /std/weapon.c () unwield\_me()}

Unwield the weapon


\subsubsection{unwield\_wep}

{\em /std/weapon.c () unwield\_wep(what)}

Unwield the weapon.

{\bf Arguments:}
\begin{itemize}
\item     what: What to unwield.
\end{itemize}


\subsubsection{wield\_access}

{\em /std/weapon.c (public) wield\_access(what)}

Check that what we try to get is a weapon and that we carry it


\subsubsection{wield\_me}

{\em /std/weapon.c () wield\_me()}

Wield this weapon
Return error message, write success message. Return 1 if success.


\subsubsection{wield\_wep}

{\em /std/weapon.c (public) wield\_wep(string str)}

wield the weapon.

{\bf Arguments:}
\begin{itemize}
\item     what: what to wield.
\end{itemize}


\subsection{xcombat}
\subsubsection{add\_hitloc}

{\em /std/xcombat.c (static) add\_hitloc(int *ac, int prchit, string desc, int id)}

Add a hitlocation to the hitloc array

{\bf Arguments:}
\begin{itemize}
\item     
\item ac:    The ac's for a given hitlocation
\item \%hit:  The chance that a hit will hit this location
\item desc:  String describing this hitlocation, ie "head", "tail"
\item id:    Specific id, for humanoids A\_TORSO, A\_HEAD etc
\end{itemize}

{\bf Returns:}        True if added.


\subsubsection{cb\_add\_enemy}

{\em /std/xcombat.c (public) cb\_add\_enemy(object enemy, int force)}

Used to add enemies to 'me'

{\bf Arguments:}
\begin{itemize}
\item      enemy: The enemy to be
\item force: If true and enemy array full one other is replaced
\end{itemize}


\subsubsection{cb\_adjust\_combat\_on\_move}

{\em /std/xcombat.c (public) cb\_adjust\_combat\_on\_move(int leave)}

Called to let movement affect the ongoing fight. This
is used to print hunting messages.

{\bf Arguments:}
\begin{itemize}
\item     True if leaving else arriving
\end{itemize}


\subsubsection{cb\_attack}

{\em /std/xcombat.c (public) cb\_attack(object victim)}

Called by the internal combat routines to attack.

{\bf Arguments:}
\begin{itemize}
\item      victim: The object of the attack                
\end{itemize}


\subsubsection{cb\_attacked\_by}

{\em /std/xcombat.c (public) cb\_attacked\_by(object ob)}

This routine is called when we are attacked or when 
someone we are hunting appears in our location.

{\bf Arguments:}
\begin{itemize}
\item      ob: The attacker
\end{itemize}


\subsubsection{cb\_damage}

{\em /std/xcombat.c (public) cb\_damage(int wcpen, int ac, object att, object def)}

Default routine for deciding damage on a given wcpen/ac
Is supposed to be replaced in \\ humanoid/creature combat

{\bf Arguments:}
\begin{itemize}
\item     wcpen:    Weapon class penetration of attack
\item ac:       Armour class against attack
\item att:      Attacker
\item def:      Defender
\end{itemize}


\subsubsection{cb\_death\_occured}

{\em /std/xcombat.c (public) cb\_death\_occured(object killer)}

Called when 'me' dies

{\bf Arguments:}
\begin{itemize}
\item      killer: The enemy that caused our death.
\end{itemize}


\subsubsection{cb\_got\_hit}

{\em /std/xcombat.c (public) cb\_got\_hit(int hid, int ph, object att, int dt)}

Tells us that we got hit. It can be used to reduce the ac
for a given hitlocation for each hit. This is supposed to be
replaced by a more intelligent routine in creature and
humanoid combat. (called from cb\_hit\_me)

{\bf Arguments:}
\begin{itemize}
\item      hid:   The hitloc id
\item ph:    The \%hurt
\item att:   Attacker
\item dt:    The damagetype
\end{itemize}


\subsubsection{cb\_heal}

{\em /std/xcombat.c (public) cb\_heal(int delay)}

Heals the living object. Adds hp, mana and fatigue

{\bf Arguments:}
\begin{itemize}
\item      delay: Number of heart\_beats since last heal
\end{itemize}

{\bf Returns:}         0 if we healed 'me'


\subsubsection{cb\_hit\_me}

{\em /std/xcombat.c (public) cb\_hit\_me(int wcpen, int dt, object attacker, int attack\_id)}

Called to decide damage for a certain hit on 'me'.

{\bf Arguments:}
\begin{itemize}
\item     wcpen:    Weapon class penetration
\item dt:       Damage type
\item attacker: 
\item attack\_id:
\end{itemize}

{\bf Returns:}        Result of hit: (\{ proc\_hurt, hitloc description \})


\subsubsection{cb\_link}

{\em /std/xcombat.c (public) cb\_link()}

Called by the internal combat routines on startup


\subsubsection{cb\_query\_enemy}

{\em /std/xcombat.c (public) cb\_query\_enemy(int arg)}

Gives our current enemy that we are fighting

{\bf Arguments:}
\begin{itemize}
\item      arg: Enemy number, (-1 == all enemies)
\end{itemize}

{\bf Returns:}        Object pointer to the enemy


\subsubsection{cb\_remove\_arm}

{\em /std/xcombat.c (public) cb\_remove\_arm(object arm)}

Remove an armour

{\bf Arguments:}
\begin{itemize}
\item     arm - The armour.
\end{itemize}


\subsubsection{cb\_reward}

{\em /std/xcombat.c (public) cb\_reward(object attacker, int dam, int kill)}

Reward the attacker of 'me'. Can be replaced.

{\bf Arguments:}
\begin{itemize}
\item     attacker:   Enemy that attacks 'me'
\item dam:        The amount of damage in hitpoints made
\item kill:       True if the attack killed me
\end{itemize}


\subsubsection{cb\_run\_away}

{\em /std/xcombat.c (public) cb\_run\_away(string dir)}

'me' runs away from the fight

{\bf Arguments:}
\begin{itemize}
\item      dir: The first dir tried
\end{itemize}


\subsubsection{cb\_stop\_fight}

{\em /std/xcombat.c (public) cb\_stop\_fight(mixed elist)}

Stop fighting certain enemies


\subsubsection{cb\_tohit}

{\em /std/xcombat.c (public) cb\_tohit(int aid, int wchit, object vic)}

Decide if we hit our victim or not. This is supposed to be
replaced by a more intelligent routine in creature and
humanoid combat. (called from heart\_beat)

{\bf Arguments:}
\begin{itemize}
\item      aid:   The attack id
\item wchit: Weapon class 'to hit'
\item vic:   The intended victim
\end{itemize}

{\bf Returns:}        True if hit, otherwise 0.


\subsubsection{cb\_ucombat\_config}

{\em /std/xcombat.c (public) cb\_ucombat\_config()}

Configure 'me' for unarmed combat. This will be 
defined in humanoid and creature combat.


\subsubsection{cb\_unwield}

{\em /std/xcombat.c (public) cb\_unwield(object wep)}

Unwield a weapon.

{\bf Arguments:}
\begin{itemize}
\item     wep - The weapon to unwield.
\end{itemize}

{\bf Returns:}        None.


\subsubsection{cb\_wield\_weapon}

{\em /std/xcombat.c (public) cb\_wield\_weapon(object wep)}

Wield a weapon.

{\bf Arguments:}
\begin{itemize}
\item     wep - The weapon to wield.
\end{itemize}

{\bf Returns:}        True if wielded.


\subsubsection{combat\_attack}

{\em /std/xcombat.c () combat\_attack(object victim)}

Called by the internal combat routines to attack.

{\bf Arguments:}
\begin{itemize}
\item      victim: The object of the attack                
\end{itemize}


\subsubsection{combat\_attacked\_by}

{\em /std/xcombat.c (public) combat\_attacked\_by(object ob)}

This routine is called when we are attacked.

{\bf Arguments:}
\begin{itemize}
\item      ob: The attacker
\end{itemize}


\subsubsection{combat\_comp\_armour}

{\em /std/xcombat.c (static) combat\_comp\_armour()}

Compute the total armour classes.


\subsubsection{combat\_hit\_me}

{\em /std/xcombat.c (public) combat\_hit\_me(int damx, object with\_weapon)}

Called to decide damage for a certain hit on 'me'.

{\bf Arguments:}
\begin{itemize}
\item     Intended damage, Used weapon
\end{itemize}

{\bf Returns:}        Killer if relevent


\subsubsection{combat\_link}

{\em /std/xcombat.c () combat\_link()}

Called by the internal combat routines on startup


\subsubsection{combat\_query\_enemy}

{\em /std/xcombat.c (public) combat\_query\_enemy(int arg)}

Gives our current enemy that we are fighting

{\bf Arguments:}
\begin{itemize}
\item      arg: Enemy number 0 / 1
\end{itemize}

{\bf Returns:}        Object pointer to the enemy


\subsubsection{combat\_remove\_arm}

{\em /std/xcombat.c (public) combat\_remove\_arm(object arm)}

Remove an armour

{\bf Arguments:}
\begin{itemize}
\item     arm - The armour.
\end{itemize}


\subsubsection{combat\_show\_wielded}

{\em /std/xcombat.c (public) combat\_show\_wielded()}

Describe the wielded weapons.

{\bf Returns:}        True if wielded.


\subsubsection{combat\_show\_worn}

{\em /std/xcombat.c (public) combat\_show\_worn()}

Describe the worn armours.


\subsubsection{combat\_stop\_fight}

{\em /std/xcombat.c (public) combat\_stop\_fight()}

Stops the current fight


\subsubsection{combat\_unwield}

{\em /std/xcombat.c (public) combat\_unwield(object wep)}

Unwield a weapon.

{\bf Arguments:}
\begin{itemize}
\item     wep - The weapon to unwield.
\end{itemize}

{\bf Returns:}        None.


\subsubsection{combat\_wear\_arm}

{\em /std/xcombat.c (public) combat\_wear\_arm(object arm)}

Wear an armour

{\bf Arguments:}
\begin{itemize}
\item     arm - The armour.
\end{itemize}


\subsubsection{combat\_wield}

{\em /std/xcombat.c (public) combat\_wield(object wep)}

Wield a weapon.

{\bf Arguments:}
\begin{itemize}
\item     wep - The weapon to wield.
\end{itemize}

{\bf Returns:}        True if wielded.


\subsubsection{create\_object}

{\em /std/xcombat.c (public) create\_object()}

Reset the combat functions


\subsubsection{fixnorm}

{\em /std/xcombat.c (static) fixnorm(int offence, int defence)}

Normalize offensive / defensive values


\subsubsection{heart\_beat}

{\em /std/xcombat.c (static) heart\_beat()}

Do 1 round of fighting with the choosen enemy. This is
done as long as both me and enemy is alive and in the
same place.


\subsubsection{move}

{\em /std/xcombat.c () move(mixed dest, mixed nocheck)}

This object is not movable


\subsubsection{query\_ac\_for}

{\em /std/xcombat.c (public) query\_ac\_for(int type)}

Return the computed ac for a certain type.

{\bf Arguments:}
\begin{itemize}
\item     type - The type of ac to return.
\end{itemize}

{\bf Returns:}        The sought for ac.


\subsubsection{query\_attack\_id}

{\em /std/xcombat.c (public) query\_attack\_id()}

Give all attack id's

{\bf Returns:}        Array with elements as described in add\_attack


\subsubsection{query\_hitloc\_id}

{\em /std/xcombat.c (public) query\_hitloc\_id()}

Give all hitloc id's

{\bf Returns:}        Array with elements as described in add\_attack


\subsubsection{remove\_attack}

{\em /std/xcombat.c (static) remove\_attack(int id)}

Removes a specific attack

{\bf Arguments:}
\begin{itemize}
\item      id: The attack id
\end{itemize}

{\bf Returns:}        True if removed


\subsubsection{remove\_hitloc}

{\em /std/xcombat.c (static) remove\_hitloc(int id)}

Removes a specific hit location

{\bf Arguments:}
\begin{itemize}
\item      id: The hitloc id
\end{itemize}

{\bf Returns:}        True if removed


\subsubsection{weapon\_attack}

{\em /std/xcombat.c (static) weapon\_attack(object wepobj, int hitmod)}

Let the wielded weapon try to hit

{\bf Arguments:}
\begin{itemize}
\item      wepobj - The weapon.
\item hitmod - Modifier to hit.
\end{itemize}

{\bf Returns:}        True if hit else 0.


\subsubsection{wear\_arm}

{\em /std/xcombat.c (public) wear\_arm(object arm)}

Wear an armour

{\bf Arguments:}
\begin{itemize}
\item     arm - The armour.
\end{itemize}
