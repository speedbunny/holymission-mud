\section{External Functions (efun)}

\subsection{add\_action - add an action to an object}
    
    {\em void add\_action(string function, string verb, void|int part)}

    This function adds an action to the `living' object that
    the command is run by. `function' is the function name that
    is to be run when the command verb `verb' is given.

    If `part' is defined (not 0) only a part of the given verb
    need to be given for the command to work

    For example:

    add\_action("foobar", "tele", 1);
    
    will match on "tele" or "teleledning" while the whole verb
    "teleledningsanka" will have to be given for this expression:

    add\_action("foobar", "teleledningsanka", 0); or \\
    add\_action("foobar", "teleledningsanka");

    {\bf Nota Bene: }   For this action to be added to an object, the object must be
    `living', i.e. the function "enable\_commands()" must have been
    performed in the object prior to the "add\_action()".
    
    {\bf See Also: }    disable\_commands, enable\_commands, living, get\_localcmd, query\_verb


\subsection{all\_inventory - return the contents of an object}
    
    {\em object *all\_inventory(object ob)}

    This function returns an array of the objects contained in `ob'.

    If `ob' is not specified "this\_object()" is used by default.



\subsection{allocate - create an array of n elements}
    
    {\em mixed *allocate(int n);}

    This function returns an empty array of `n' elements. All
    values in the array are initialized to 0.



\subsection{break\_string - break a string at regular intervals}
    
    {\em string break\_string(string str|int foobar, int len, }
                void|int indent|string indent)

    This function breaks a continous string without newlines into a
    a string with newlines inserted at every `len':th character. 

    If `indent' is defined and is given as an integer, `indent' number
    of spaces are inserted after every newline. If `indent' is a string 
    that string is inserted before every newline.

    If the first argument is an integer, the function simply returns 0.

    {\bf See Also: }    implode, explode, sprintf



\subsection{call\_other - call a function in another object}
    
    {\em mixed call\_other(object ob|string ob, string func, ...)}

    This function is used to call another function in a given
    object. If the object `ob' is given as a string the object
    is found using "find\_object()", otherwise the object pointer
    is used directly. If the object is given as a string, the
    absolute path to the object must be given.

    `func' should simply be the name of the function to be called.
    Any number of arguments to the function can be added to the
    call.

    Example:

    \begin{verbatim}
    name = (string)call_other(find_player("commander"), "query_real_name");
    access = (int)call_other("/secure/master", "valid_read",
             "/DONE", "commander", "my_func");
    \end{verbatim}

    "call\_other()" can also be performed using "->" with this syntax:

    \begin{verbatim}
    name = (string)find_player("commander")->query_real_name();
    access = (int)"/secure/master"->valid_read("/DONE", "commander", 
             "my_func");
    \end{verbatim}
    
    {\bf Nota Bene: }   The default type of "call\_other()" is mixed, but as shown in the
    examples above it is always possible to cast to a type of your
    own choosing, if nothing else only to aid memory.



\subsection{call\_out - delayed execution of a function}
    
    {\em void call\_out(string func, int delay, void|mixed arg)}

    With this function you can delay the call of a name function
    `func' for `delay' seconds. If `arg' is specified it is passed
    as an argument to the function.

    {\bf Nota Bene: }   Neither "this\_interactive()" nor "this\_player()" is defined
    in a function that has been called by "call\_out()". If you
    have a `write()' statement in the function that is called 
    with `call\_out()' the output will end up in the game log.

    The smallest time-unit in the game is a heartbeat (2 seconds). 
    This means that even though you might specify an odd-second delay, 
    it will still be executed on a full heartbeat (even second).

{\bf See Also: }
    call\_out\_info


\subsection{capitalize - capitalize the first word of a string}
    
    {\em string capitalize(string str|int foobar)}

    With this command the first letter of a string is made
    upper-case. If the argument given is an integer, a 0 is
    returned.

    {\bf See Also: }    lower\_case



\subsection{cat - print part of a file on the screen}
    
    {\em int cat(string file, void|int start, void|int len)}

    This functions prints a file or a part of a file on to the
    screen. `file' is the path the file, `start' (if given) is
    the starting line and `len' (if given) the number of lines 
    to be printed



\subsection{cindent - indent and format an LPC program source file}

    {\em int cindent(string path)}

    Indents and formats the named file in the same way as the
    UNIX program indent.

    {\bf See Also: }    ed


\subsection{clear\_bit - clear a bit in a string bitfield}

    {\em string clear\_bit(string bitstring, int pos)}

    This function will clear the indicated bit in the given bitstring.

    {\bf See Also: }    set\_bit, test\_bit


\subsection{clone\_object - clone an object}

    {\em object clone\_object(string path)}

    This funciton clones an object indicated by the path. However,
    this is subject to the rules defined in the function `valid\_read()'
    in `/secure/master.c'

    {\bf See Also: }    destruct


\subsection{command - execute a command in a living object}

    {\em int command(string command)}

    With this function an object can command itself to perform
    an action that previously has been added with add\_action.
    The given string `command' should be on the same format as
    if it had been given from the command line.

    `command()' returns the number eval-cycles that was used to perform
    the command, or 0 if it proved impossble due to eval-cost.

    A force function can then simply be implemented in the player-
    object like this:

    \begin{verbatim}
    nomask int /* We'd rather not have anyone shadowing this function */
    force_player(string command)
    {
        if (ok_to_force())
            if (command(command))
            return 1;

        return 0;
    }
    \end{verbatim}

    The function `ok\_to\_force()' can then determine if it is permitted
    for the person that tries to execute the command to force the
    player or not.



\subsection{crypt - encrypt a string}

    {\em string crypt(string data, string key|int random)}

    This function encrypts the given `data' using the given encryption
    `key'. If the the second argument is given as an integer, the
    encryption is done with a random key.



\subsection{ctime - convert time stamp to string}

    {\em string ctime(int time)}

    This funtion converts the given `time' to a string.

    {\bf See Also: }    time



\subsection{deep\_inventory - recursive inventory of an object}

    {\em object *deep\_inventory(object ob|int foobar)}

    This function returns a list of the all the objects contained
    by the given `object' including the objects contained in other
    objects. The inventory of `object' is searched recursively in
    order to produce this list.

    If an integer is given as argument, 0 is returned. If no argument
    is given, `this\_object()' is used by default.

    {\bf See Also: }    inventory, environment



\subsection{destruct - destruct an object}

    {\em void destruct(object ob)}

    This function destroys the indicated object.

    {\bf Nota Bene: }   It is usually better to call the `remove()' function provided 
    in the mudlib object code than to use this efun. The mudlib code
    will handle such things as light, weight and volume-updating
    when called, something that this efun will ignore completly. 

    Use this function as a last-resort method of getting rid of
    otherwise indestructable objects.

    {\bf See Also: }    clone\_object


\subsection{disable\_commands - set an object `non-living'}

    {\em void disable\_commands()}

    With this function an object is made `non-living'. This disables
    the adding of commands from entering rooms or objects that move
    into the inventory of this object.

    {\bf See Also: }    enable\_commands, move\_object


\subsection{ed - edit a file}

    {\em void ed(void|string path, void|string exit\_func)}

    With this function an interactive object (a player) can edit
    a file with the given path. If no `path' is given, the player
    is expected to save the file from inside the editor. `exit\_func' 
    is called on completion of the command.

    This function is subject to the rules given by the functions
    `valid\_read()' and `valid\_write()' in `/secure/master.c'



\subsection{enable\_commands - set an to be object `living'}

    {\em void enable\_commands(void)}

    This function makes an object `living'. It will now pick up
    commands defined by `add\_action()' and can listen to what is
    said in its environment.

    {\bf See Also: }    disable\_commands, move\_object



\subsection{environment - find the environment of an object}

    {\em object environment(object ob)}

    This function returns the object that has `ob' in its inventory, 
    the environment of `ob'. If no object is given as argument,
    `this\_object()' is used by default.

    If no environment to `ob' is found, 0 is returned.

    {\bf See Also: }    inventory, deep\_inventory

    {\bf Caveat: }
    {\bf Bugs: }

\subsection{exec - connect a socket to a new object}

    {\em int exec(object new, object old)}

    This function is used to shift an interactive user betwen two
    objects. The function `valid\_exec()' is called in `/secure/master.c'
    with the calling object as argument. If `valid\_write()' accepts
    the calling object the interactive user is switched from the object
    `old' to `new'.

    {\bf Nota Bene: }   It is very easy to become confused when writing the code that uses
    this efun. All the internal variables like `this\_player()' or
    `this\_object()' remain unchanged, it is just the user that is 
    switched between the objects.

    {\bf Caveat: }  This is one of the greater threats to security in the system. Unless
    the use is this efun is rigorously restricted anyone can become arch
    or keeper.

{\bf Friendly Advice:}
    Don't do this unless you're damn certain you what you are doing.



\subsection{explode - explode a string into subparts}

    {\em string *explode(string str, string break\_string)}

    This function returns an array of the strings resulting from
    dividing `str' into the component strings separated by 
    `break\_string'. If `break\_string' is given as "", `str' is
    broken into its component characters.

    {\bf See Also: }    implode, break\_string, sprintf


\subsection{export\_uid - export the current objects effective userid an object}

    {\em int export\_uid(object recieveob)}

    This function exports the effective userid of `this\_object()' to 
    `recieveob'.
    
    `this\_object()' must have an effective userid set and `reciveob' 
    must have it cleared for this function to succeed.
    
    {\bf See Also: }    getuid, setuid, seteuid, geteuid, 



\subsection{extract - extract a subpart of a string}

    {\em string extract(string str, void|int start, void|int to)}

    Get a subpart of a string. Both 'start' and 'to' is a position in
    'str'. If the position(s) is negative then it is counted from the
    end of the string.

    If the 'start' is bigger or equal to 'to' then an empty string is
    returned. An empty string is also returned if the subpart is
    outside the string in its entirety.

    Both positions is optional. If no position is given then 'str' is
    returned.

    If only 'start' is given then a string from 'start' to the end of
    'str' is returned.

    {\bf See Also: }    capitalize, lower\_case, explode, implode


\subsection{file\_name - find the filename of an object}

    {\em string file\_name(object ob)}

    This function gives the filename of an object concatenated with
    a possible instance number. This typically is a string on the
    form "/std/weapon\#423". Instance numbers are unique for all
    objects in the game.

    If a filename has no instance number it is the 'master object' and
    not a 'cloned copy'. 



\subsection{file\_size - return the size of a file}

    {\em int file\_size(string path)}

    This function returns the size, in bytes, of an existing file. If the
    file does not exist, file\_size returns -1.

    If the file is actually a directory and not a file, -2 will be
    returned.

    {\bf See Also: }    file\_time, file\_name



\subsection{file\_time - return the last modification time for a file}

    {\em int file\_time(string path)}

    Gives the time in seconds since whatever 1970, when the file was last
    modified. 
    
    {\bf See Also: }    time, ctime, object\_time, file\_size, file\_name



\subsection{filter - filter an array or a mapping through a specific }
         filter function

    {\em mixed *filter(int foobar|mixed *arr|mapping map, string filter, }
                object ob|string ob, void|mixed extra)

    This function is used to filter all items in an array or a mapping
    through a specific function. The resulting array or mapping contains
    all elements in the original array or mapping that the function
    `filter' returned 1 for while all those that a 0 was returned for
    was discarded.

    If an integer is given as argument instead of an array or mapping,
    0 is returned.

    `filter' is simply given as a string with the name of the filter
    function to use.

    `ob' is either the actual object that contains the filter function
    or a path to to the object.

    `extra' can be any argument that you would like the `filter' 
    function to recieve as argument.

    {\bf See Also: }    map



\subsection{find\_call\_out - find the remaining call\_out time of a function}

    {\em int find\_call\_out(string func)}

    This function returns the number of seconds left until the given
    function `func' is to be executed.

    {\bf See Also: }    call\_out, remove\_call\_out



\subsection{find\_living - find a named living object}

    {\em object find\_living(string name)}

    This function returns the living object with the given `name'.

    The argument `name' must be given in lowercase for this function
    to work.

    {\bf Nota Bene: }   For this function to work, the object must have added its name 
    to the game-driver internal list by calling the function 
    `set\_living\_name()'. Just making it living with `enable\_commands()'
    is not enough.

    {\bf See Also: }    set\_living\_name, enable\_commands, find\_player, find\_object



\subsection{find\_object - find a named object}

    {\em object find\_object(string path\_name)}

    If the object with the specified `path\_name' is loaded, its
    pointer is returned by this function.

    If the filename is given merely as the path to the object,
    e.g. "/std/coins" the master object is returned, but it is
    possible to find specific objects by giving the name complete
    with instance number, e.g. "/std/coins\#123".

    {\bf See Also: }    present, find\_living, find\_player



\subsection{find\_player - find a named player}

    {\em object find\_player(string name)}

    This function finds and returns the player object with the given
    `name'. 

    The argument `name' must be given in lowercase for this function
    to work.

    {\bf See Also: }    find\_living, find\_object



\subsection{function\_exists - find out if a named function is defined in an}
              object and return the object filename.

    {\em string function\_exists(string func, object ob)}

    This function searches for a named function `func' in the specified
    object `ob'. If it is found, the filename of that object is returned.

    The filename returned is not the same as the string returned by
    the function `file\_name()', it does not have the instance number
    of the found object suffixed to it.

    If no argument `ob' is given, `this\_object()' is used by default.

    {\bf Nota Bene: }   It is the filename of the object that contains the function that
    is returned, not the composite object that might inherit the file
    that contains the function.

    E.g: the expression 
    
        function\_exists("create\_container", find\_living("orc"))

    will always return "/std/living".

    {\bf See Also: }    inherit\_list


\subsection{get\_dir - return an array of filenames in a directory}

    {\em string *get\_dir(string path)}

    This function returns the names of all files contained in the
    specified directory.

    The function is subject to the rules defined by the function
    `valid\_read()' in `/secure/master.c'.



\subsection{get\_localcmd - return an array of an object's locally define commands}

    {\em string *get\_localcmd(object ob|int foobar)}

    This function returns an array of all local commands added to
    the object `ob'. 

    If no argument is givent `this\_object()' is used by default.

    If an integer is given as argument, 0 is returned.



\subsection{geteuid - give the effective userid of an object}

    {\em string geteuid(object ob)}

    This function returns the effective userid of the specified 
    object `ob'. 

    If no argument `ob' is given, `this\_object()' is used by default.

    {\bf See Also: }    getuid, setuid, seteuid



\subsection{geteuid - give the userid of an object}

    {\em string getuid(object ob)}

    This function returns the userid of the specified object `ob'.

    If no argument `ob' is given, `this\_object()' is used by default.

    {\bf See Also: }    getuid, setuid, seteuid



\subsection{implode - concatenate an array of strings}

    {\em string implode(int foobar|string *arr, string pad)}

    This function concatenates all strings contained in `arr' with
    the string `pad' inserted between them.

    {\bf See Also: }    explode, break\_string, sprintf



\subsection{inherit\_list - return a list of all inherited objects of an object}

    {\em string *inherit\_list(object ob)}

    This function returns a list of all files that are inherited in
    the specified object `ob'.

    If no argument `ob' is given, `this\_object()' is used by default.



\subsection{input\_to - redirect keyboard input to a function}

    {\em void input\_to(string func, void|int noecho)}

    With this function it is possible to redirect the keyboard
    input from a player into a function.

    The function `func' is then called with the string the player
    wrote as argument. If `noecho' is given, the string is not
    echoed on the player's screen.

    {\bf Nota Bene: }   This only works for interactive players. This will not work
    for an npc of any kind.



\subsection{interactive - determine if an object is interactive or not}

    {\em int interactive(object ob)}

    This function returns 1 if the specified object `ob' is an
    interactive player and 0 otherwise.

    If no argument is given, `this\_object' is used by default.

    {\bf See Also: }    this\_interactive, this\_player



\subsection{intp - determine if a variable is of type int}

    {\em int intp(mixed testvar)}

    This function return 1 if `testvar' was of the type integer,
    and 0 otherwise.

    {\bf See Also: }    mappingp, stringp, pointerp, objectp



\subsection{living - determine if an object is living}

    {\em int living(object ob|int foobar)}

    This function returns 1 if the specified object `ob' is
    living and 0 otherwise.
    
    If the given argument is an integer, 0 is returned.

    {\bf See Also: }    enable\_commands



\subsection{lower\_case - decapitalize the first word of a string}

    {\em string lower\_case(string str|int foobar)}

    This function returns a string that is a copy of the argument
    string `str' but with the first letter lower-case. 

    If an integer is given as argument, 0 is returned.

    {\bf See Also: }    capitalize





\subsection{m\_delete - delete entries in a mapping}

    {\em void m\_delete(mapping map|in foobar, mixed *dellist)}

    This function is used to remove one or more entries in a mapping.

    The first argument `map' should be the mapping you want to remove
    entries from.

    The second argument `dellist' should be an array containing the
    indexes of all entries you want removed.

    If the first argument is given as an integer, 0 is returned.

    {\bf See Also: }    mkmapping, m\_indexes, m\_values, m\_delete, mappingp



\subsection{m\_indexes - return the domain of a mapping}

    {\em mixed *m\_indexes(mapping map|int foobar)}

    This function returns the domain, the `index' part, of a mapping
    as an array. 

    If an integer is given as argument, 0 is returned. 

    {\bf See Also: }    mkmapping, m\_values, m\_sizeof, m\_delete, mappingp


 
\subsection{m\_sizeof - return the cardinality of a mapping}

    {\em int m\_sizeof(mapping map|int foobar)}

    Return the number of mapping pairs contained in a mapping.
    If an integer is given as argument, 0 is returned.

    {\bf See Also: }    mkmapping, m\_indexes, m\_values, m\_delete, mappingp



\subsection{m\_values - return the co-domain of a mapping}

    {\em mixed *m\_values(mapping map|int foobar)}

    This function returns the co-domain, the `vaplue' part, of a mapping
    as an array. 

    If an integer is given as argument, 0 is returned. 

    {\bf See Also: }    mkmapping, m\_indexes, m\_sizeof, m\_delete, mappingp


\subsection{map - map a function onto each element of an array or a mapping}

    {\em mixed *map(int foobar|mixed *array|mapping map, string map,}
             object ob|string ob, mixed extra)

    This function is used to process all items in an array or a mapping
    through a specific function. The resulting array or mapping contains
    whatever was returned by the `map' function.

    If an integer is given as argument instead of an array or mapping,
    0 is returned.

    `map' is simply given as a string with the name of the processing
    function to use.

    `ob' is either the actual object that contains the filter function
    or a path to to the object.

    `extra' can be any argument that you would like the `map' 
    function to recieve as argument.

    {\bf See Also: }    filter



\subsection{mappingp - determine if the value of a variable is a mapping}

    {\em int mappingp(mixed testvar)}

    This function return 1 if `testvar' was of the type mapping,
    and 0 otherwise.

    {\bf See Also: }    intp, stringp, pointerp, objectp



\subsection{member\_array - find the position of an element in an array}

    {\em int member\_array(mixed element, int foobar|mixed *array)}

    Gives the index in 'array' which is occupied with the value 'element'.
    If 'element' is not found or an integer is given instead of an array
    as second argument, -1 is returned.

    Searching works like the equality operator, ie integers and strings
    are compared for equality and arrays and mappings for identity.

    This means that integers and strings must have the same value to match,
    while arrays and mappings must be the exact same.



\subsection{mkdir - make a directory}

    {\em int mkdir(string pathname)}

    Makes a directory with the pathname 'pathname'. If it returns 1 then
    the directory was successfully created.

    If it fails 0 is returned.

    {\bf See Also: }    rmdir



\subsection{mkmapping - make a mapping from an array}

    {\em mapping mkmapping(mixed *array|int foobar)}

    This function returns a mapping with the indexes being a
    continous list from 0 to `sizeof(array)'. The values are
    all set to 0.

    If an integer is given as argument, 0 is returned.

    {\bf See Also: }    m\_indexes, m\_values, m\_sizeof, m\_delete, mappingp



\subsection{move\_object - move the current object somewhere}

    {\em void move\_object(object dest|string destfilename)}

    Moves the object executing the function to the destination indicated
    by 'dest' or if the argument is a string 'destfilename' then 
    move\_object tries to load the corresponding object and move 
    this\_object to that destination.

    When an object moves from a destination all the commands it has
    defined in nearby objects using add\_action through init, will be
    automatically removed. If this\_object is a living object then
    all commands from nearby objects will be removed automatically.

    Upon entering the destination object each living object which becomes
    nearby will be set to this\_player respectively and init will be run
    in the entering object. Thus letting it add its commands with 
    add\_action to each nearby living object.

    If the entering object is itself living, then this\_player will be
    set to the entering object and init will be called in each object
    already in the destination. Init will also be called in the
    destination object which is normally a room.

    {\bf Nota Bene: }   You normally do not use move\_object directly. Instead there is
    a lfun move() in the object which should be called. This ensures
    that things like light, weight, volumes and heaps to be updated
    correctly.

    {\bf See Also: }    add\_action, enable\_commands, disable\_commands, this\_player

    {\bf Caveat: }  As init is called from 'within' the move\_object function, care must
    be taken that an infinit loop is not created by moving the wrong
    object within an init routine. If you are doubtful, never move
    an object in init.



\subsection{notify\_fail - give a message to be printed if all commands failed}

    {\em void notify\_fail(string message)}

    With this function you can set a message that will be printed instead
    of the notorious 'What ?' when all commands fail. The message will be
    passed through process\_string which allows you to decide the
    content of the string 'late' and also do other things in the
    function(s) called through process\_string.

    {\bf See Also: }    process\_string     


\subsection{object\_time - return the time when the object was created}

    {\em int object\_time(object ob)}

    Gives the time in seconds since whatever 1970, when the object
    was created.
    
    {\bf See Also: }    time, ctime, file\_time



\subsection{objectp - true if the value of a variable is an object}

    {\em int objectp(mixed testvar)}

    This function return 1 if `testvar' was of the type object,
    and 0 otherwise.

    {\bf See Also: }    intp, stringp, pointerp, mappingp



\subsection{parse\_command - try to match a string with a given pattern}

    {\em int parse\_command(string command, object env|object *oblist,}
              string pattern, mixed arg, ...)

  This is one of the most complex efun in LPmud to use. It takes
  some effort to learn and use, but when mastered, very powerfull constructs
  can be implemented.

  Basically parse\_command() is a piffed up sscanf operating on word basis. It
  works similar to sscanf in that it takes a pattern and a variable set of
  destination arguments. It is together with sscanf the only efun to use
  pass by reference for other variables than arrays.

  To make the efun usefull it must have a certain support from the mudlib,
  there is a set of functions that it needs to call to get relevant
  information before it can parse in a sensible manner.

  In earlier versions it used the normal id() lfun in the LPC objects to
  find out if a given object was identified by a certain string. This was
  highly inefficient as it could result in hundreds or maybe thousands of
  calls when very long commands were parsed. 
  
  The new version relies on the LPC objects to give it three lists of 'names'.
  
\begin{itemize}
\item  1 - The normal singular names.
\item  2 - The plural forms of the names.
\item  3 - The acknowledged adjectives of the object.
\end{itemize}

  These are fetched by calls to the functions:

\begin{itemize}
\item    1 - string *parse\_command\_id\_list();
\item    2 - string *parse\_command\_plural\_id\_list();
\item    3 - string *parse\_command\_adjectiv\_id\_list();
\end{itemize}

  The only really needed list is the first. If the second does not exist
  than the efun will try to create one from the singluar list. For 
  grammatical reasons it does not always succeed in a perfect way. This is
  especially true when the 'names' are not single words but phrases.

  The third is very nice to have because it makes constructs like
  'get all the little blue ones' possible.

  Apart from these functions that should exist in all objects, and which
  are therefore best put in /std/object.c there is also a set of functions
  needed in /secure/master.c These are not absolutely necessary but they
  give extra power to the efun.

  Basically these /secure/master.c lfuns are there to give default values
  for the lists of names fetched from each object.

  The names in these lists are applicable to any and all objects, the first
  three are identical to the lfun's in the objects:
  \begin{verbatim}
       string *parse_command_id_list()
                - Would normally return: ({ "one", "thing" })

       string *parse_command_plural_id_list()
                - Would normally return: ({ "ones", "things", "them" })

       string *parse_command_adjectiv_id_list()
                - Would normally return ({ "iffish" })
  \end{verbatim}

  The last two are the default list of the prepositions and a single so called
  'all' word. 

  \begin{verbatim}
       string *parse_command_prepos_list()
                 - Would normally return: ({ "in", "on", "under" })

       string parse_command_all_word()
                 - Would normally return: "all"
  \end{verbatim}

  The function returns 1 if 'command' is considered to have matched 'pattern'.
  The 'env' or 'oblist' parameter either holds an object or a list of objects.
  If it holds a single object than a list of objects are automatically
  created by adding the deep\_inventory of the object, ie this is identical:

    parse\_command(cmd, environment(), pattern, arg) and \\
    parse\_command(cmd, (\{ environment() \}) + deep\_inventory(environment()),
              pattern, arg)

  'pattern' is a list of words and formats:

    Example string = " 'get' / 'take' \\%i "
    {\bf Syntax:}
    \begin{itemize}
    \item{'word'}   obligatory text
    \item{[word]}   optional text
    \item{/}        Alternative marker
    \item{\verb+\%o+}   Single item, object
    \item{\verb+\%l+}   Living objects
    \item{\verb+\%s+}   Any text
    \item{\verb+\%w+}    Any word
    \item{\verb+\%p+}   One of a list (prepositions)
    \item{\verb+\%i+}   Any items
    \item{\verb+\%d+}    Number 0- or tx(0-99)
    \end{itemize}

    The 'arg' list is zero or more arguments. These are the result variables
    as in sscanf. Note that one variable is needed for each \verb+\%_+

    The return types of different \verb+\%_+ is:
    \begin{itemize}
    \item{\verb+\%+o}   Returns an object
    \item{\verb+\%+s}   Returns a string of words
    \item{\verb+\%+w} Returns a string of one word
    \item{\verb+\%+p}   Can on entry hold a list of word in array
                or an empty variable \\
            {\bf Returns:}
            \begin{itemize}
            \item if empty variable: a string
            \item if array: array[0]=matched word
            \end{itemize}
    \item{\verb+\%+i}   Returns a special array on the form: \\
            $[0] = (int) +(wanted) -(order) 0(all)$ \\
            \verb+[1..n]+ (object) Objectpointers
    \item{\verb+\%+l}   Returns a special array on the form: \\
            $[0] = (int) +(wanted) -(order) 0(all)$ \\
            \verb+[1..n]+ (object) Objectpointers \\
            These are only living objects.
    \item{\verb+\%+d} Returns a number
    \end{itemize}

  The only types of \verb+\%+ that uses all the loaded information from the objects
  are \verb+%+i and \verb+%+l. These are in fact identical except that \verb+%+l filters out
  all nonliving objects from the list of objects before trying to parse.

  The return values of \verb+%+i and \verb+%+l is also the most complex. They return an
  array consisting of first a number and then all possible objects matching.
  As the typical string matched by \verb+%+i/\verb+%+l looks like: 'three red roses',
  'all nasty bugs' or 'second blue sword' the number indicates which 
  of these numerical constructs was matched:
  
        \begin{itemize}
        \item if numeral \verb+>+0 then three, four, five etc were matched
        \item if numeral \verb+<+0 then second, twentyfirst etc were matched
        \item if numeral==0 then 'all' or a generic plural form such as 'apples'
                            were matched.
        \end{itemize}

    {\bf Note:}
       The efun makes no semantic implication on the given numeral. It does
       not matter if 'all apples' or 'second apple' is given. A \verb+%+i will
       return ALL possible objects matching in the array. It is up to the
       caller to decide what 'second' means in a given context.

       Also when given an object and not an explicit array of objects the
       entire recursive inventory of the given object is searched. It is up
       to the caller to decide which of the objects are actually visible
       meaning that 'second' might not at all mean the second object in
       the returned array of objects.
            
    {\bf See Also: }    sscanf, deep\_inventory

    {\bf Caveat: }  Patterns of type: "\verb+%+s \verb+%+w \verb+%+i"
    Might not work as one would expect. \verb+%+w will always succeed so the arg
    corresponding to \verb+%+s will always be empty.

    {\bf Bugs:}    Patterns of the type: 'word' and [word]
    The 'word' can not contain spaces. It must be a single word. 
    This is so because the pattern is exploded on " " (space) and a
    pattern element can therefore not contain spaces.

{\bf Example:}
    \begin{verbatim}
     if (parse_command("spray car",environment(this_player()),
                          " 'spray' / 'paint' [paint] %i ",items))  
     {  
        /*
          If the pattern matched then items holds a return array as
          described under 'destargs' %i above.
        */
     }
    \end{verbatim}


\subsection{pointerp - determine if the value of a variable is an array}

    {\em int pointerp(mixed testvar)}

    This function return 1 if `testvar' was of the type pointer,
    and 0 otherwise.

    {\bf See Also:}    intp, stringp, mappingp, objectp



\subsection{present - find a present object through its id() function}

    {\em object present(object ob|string ob, object *where|object where)}

    This function returns the specified object `ob' if it is found
    in the inventory of the object(s) `where'. The object `ob' can
    be given either as an actual object or as a string.

    `where' can either be one object or an array of objects to search
    through.

    If the object is not present, 0 is returned.

    {\bf See Also: }    find\_object



\subsection{previous\_object - give object that called current object}

    {\em object previous\_object()}

    This function returns the previous object that called a function
    in this object from the outside, ie with `call\_other()'. 

    This include `call\_other(this\_object(), ...)' constructions. In 
    this case, the returned value will be `this\_object()'.

    {\bf Caveat: }  If the function was called internally, the result is undefined.



\subsection{process\_string - give a string with replaced calldescriptions}

    {\em string process\_string(string combinestring)}

    Processes a string by replacing specific syntactic patterns with
    what is returned when the pattern is interpreted as a function
    call description.

    The syntactic patterns are on the form:

\begin{verbatim}
           "@@function[:filename][|arg1|arg2....|argN]@@"
\end{verbatim}

    This is interpreted as a call:

\begin{verbatim}
        filename->function(arg1, arg2, ....., argN)
\end{verbatim}

    Note that process\_string does not recurse over returned
    replacement values. If a function returns another syntactic
    pattern, that description will not be replaced.

    All such occurrences in 'combinestring' is processed and replaced if
    the return value is a string. If the return value is not a string
    the the pattern will remain unreplaced.

    Note that both object and arguments are marked optional with the
    brackets and that the brackets are not included in the actual pattern.

    {\bf See Also: }    process\_value

    {\bf Caveat: }  This is usually used to support 'value by function call' in the mudlib.
    It is wise to set the effuserid of the object to 0 before using
    process\_value as any function in any object can be called with almost
    any arguments.

{\bf Example:}
    A string:   

      "You are chased by @@query\_the\_name:/obj/monster\#123@@ eastward."

    is replaced by: 

      "You are chased by the orc eastward."

        Assuming that query\_the\_name in monster\#123 returns "the orc".



\subsection{process\_value - give a value from a described function call}

    {\em mixed process\_value(string calldescription)}

    Get the replacement of one syntactic pattern. The pattern is on
    the form:

           "function[:filename][|arg1|arg2....|argN]"

    The returned value can be of any type.

    Note that both object and arguments are marked optional with the
    brackets and that the brackets are not included in the actual pattern.

    {\bf See Also: }    process\_string

    {\bf Caveat: }  This is usually used to support 'value by function call' in the mudlib.
    It is wise to set the effuserid of the object to 0 before using
    process\_value as any function in any object can be called with almost
    any arguments.



\subsection{query\_host\_name - give the hostname that the gamedriver is running on}

    {\em string query\_host\_name()}

    Gives the name of the machine that the game is running on



\subsection{query\_idle - give time since last command from a player}

    {\em int query\_idle(object player)}

    Returns the number of seconds that an interactive player has been
    idle, ie the time since the last command was issued.    

    {\bf Nota Bene: }   This is only relevant to interactive players and are not implemented
    for npc's.



\subsection{query\_ip\_name - give the hostname from which a player is connected}

    {\em string query\_ip\_name(void|object player)}

    Gives the host name of an interactive player, ie from which site
    the player is connecting to the game.
    
    The string returned is on the form: "milou.cd.chalmers.se"

    {\bf See Also: }    query\_ip\_number

    {\bf Bugs: }    This function demands an external process to be active on the
    machine running the gamedriver. If that process is not active
    query\_ip\_name will return the same as query\_ip\_number, always.



\subsection{query\_ip\_number - give the ip number for a player}

    {\em string query\_ip\_number(void |object player)}

    Gives the ip number of an interactive player, ie from which site
    the player is connecting to the game.
    
    The string returned is on the form: "129.16.48.2"

    {\bf See Also: }    query\_ip\_name


\subsection{query\_load\_average - give a load average status message}

    {\em string query\_load\_average()}

    Returns a string on the form:
        "0.68 cmds/s, 29.40 comp lines/s"

    This indicate the current workload of the gamedriver.


\subsection{query\_snoop - check what object is snooping a given object}

    {\em object query\_snoop(object snoopee)        }
    
    Gives objectpointer to the player that is snooping 'snoopee'. This
    function can only be executed by `/secure/master.c'

    {\bf See Also: }    snoop


\subsection{query\_verb - give the currently active verb}

    {\em string query\_verb()}

    Returns the currently issued verb. This is only relevant when an
    interactive player has issued a command. This function will
    the return the first word of that command, ie all text upto but
    not including the first space.

    {\bf See Also: }    add\_action

    {\bf Caveat: }  When the verb have been added with the short verb flag, \\
                ie with {\em add\_action("function","verb",1)}
    then all text up to first space is not equivalent to what triggered
    the command to be executed.

    You must currently remember which verb you did add\_action() on
    until there exists a query\_trigverb()
    
    {\bf Bugs: }

\subsection{random - give a random value}

    {\em int random(int limit, void|int seed)}
    
    Gives a random value between 0 and 'limit - 1'. Note that the 'limit'
    must be a positive integer.

    If the optional argument 'seed' is given then a specific random
    number will be given. random will always return the same value
    for a given limit and seed.

    {\bf Nota Bene: }   The last paragraph is badly tested, please report any bugs found



\subsection{read\_bytes - read text from a given position in a file}

    {\em string read\_bytes(string filename, void|int fromchar, void|int tochar)}

    Gives the contents of the file 'filename'. If the optional arguments
    'fromchar' and 'tochar' is given then the function gives the contents
    from byte 'fromchar' to, and including the byte 'tochar'.

    {\bf Nota Bene: }   There is a maximum limit to the number of bytes that can be read. This
    limit is defined when the gamedriver is compiled and is normally
    50Kbytes.

    {\bf See Also: }    write\_file, read\_file, write\_bytes


\subsection{read\_file - read lines from a file, there is a maximum limit}

    {\em string read\_file(string filename, void|int startlin, void|int endlin)}

    Gives the contents of the file 'filename'. If the optional arguments
    'startlin' and 'endlin' is given then the function gives the textlines
    (separated by newlines), from the line 'startlin' to the line 'endlin'.

    {\bf Nota Bene: }   There is a maximum limit to the number of bytes that can be read. This
    limit is defined when the gamedriver is compiled and is normally
    50Kbytes.

    {\bf See Also: }    write\_file, read\_bytes, write\_bytes



\subsection{regexp - match a regular expression}

    {\em string regexp(string *array, string pattern)}

    Returns an array containing all matches of `pattern' in the
    strings contained in `array'.

    The rules for this operation is somewhat hazy, I haven't had
    the energy to penetrate the rather large bulk of code that
    takes care of this so for now you'll have to read the source
    code for yourself if you're interested.

    However, it seems that the rules are the same as for UNIX
    `grep', but don't count on it until you have verified by
    testing.



\subsection{remove\_call\_out - remove a named, pending call\_out for current object}

    {\em int remove\_call\_out(string funcname)}

    Removes a pending call\_out in the current object. Returns heartbeats
    left until the call out was going to take place.

    {\bf See Also: }    call\_out, find\_call\_out


\subsection{rename - rename a file or move a subdirectory}

    {\em int rename(string frompath, string topath)}

    Renames the file 'frompath' to the name 'topath'. This is functionally
    identical to copying the file 'frompath' to 'topath' and the remove
    'frompath'. 
    
    If 'topath' exists and is a file, it is removed.

    If 'topath' is a directory then move the file to that directory.

    If 'frompath' is a directory then move the entire subdirectory
    to 'topath'.

    Return 1 if UNSUCCESSFUL.

    {\bf See Also: }    rmdir, rm, mkdir

    {\bf Bugs: }    It should be changed to return 0 for unsuccessful move as all other


\subsection{restore\_object - load global variables in current object from file}

    {\em int restore\_object(string filename)}

    Loads all nonstatic global variables from a specifically formatted
    file given by 'filename'. The format of the file is:
    
    \begin{verbatim}
        variable_name  variable_value

        intvar          number
        stringvar       "stringvalue"
        arrayvar        ({ variable_values })
        mappingvar      ([ index:value ])
    \end{verbatim}

    {\bf See Also: }    save\_object


\subsection{rm - remove a file}

    {\em int rm(string filename)}

    Removes a file 'filename'. Returns 1 if successful.

    {\bf See Also: }    rmdir



\subsection{rmdir - remove an empty directory}

    {\em void rmdir(string pathname)}

    Removes an empty directory. Returns 1 on success, otherwise 0.

    {\bf See Also: }    mkdir, rm



\subsection{save\_object - save global variables in current object to a file}

    {\em void save\_object(string filename)}

    Saves all non static global variables of an object to a given file.
    All variables are saved except those currently of the type object.
    The filename gets a filetype ".o" appended and the format is:

    \begin{verbatim}
        variable_name  variable_value

        intvar          number
        stringvar       "stringvalue"
        arrayvar        ({ variable_values })
        mappingvar      ([ index:value ])
    \end{verbatim}

    {\bf See Also: }    restore\_object


\subsection{set\_bit - set a specific bit in a bitfield}

    {\em string set\_bit(string bitfield, int bitnum)}

    Sets a bit with the number 'bitnum' in a specifically coded string
    'bitfield'. The bitfield string is a string consisting of writable
    characters. Each character represents six bits.

    The 'bitfield' string is automatically extended to satisfy the setting
    of bits outside the current string size.

    {\bf Caveat: }  There is a maximum bitindex number which can be changed in config.h
    in the gamedriver source. This constant is normally 1200.



\subsection{set\_heart\_beat - turn the heart beat calling on/off in current object}

    {\em void set\_heart\_beat(int onflag)}

    This function turns on and off automatic calls every 2 seconds to
    the lfun heart\_beat. If 'onflag' is 0 then calls is turned off, 
    otherwise calling is turned on. 

    {\bf Nota Bene: }   heart\_beats are costly. Use them only if neccessary. Especially
    do not use them for 'down counters' such as counting down the
    life time of a torch, use call\_out for such purposes.

    {\bf See Also: }    call\_out

    {\bf Caveat: }  If there is a runtime error in your heart\_beat routine calling
    of the heart\_beat will be automatically turned off.



\subsection{set\_living\_name - set the searchable name for a living object}

    {\em void set\_living\_name(string name)}

    Sets a specific searchable name for a living object, ie an object
    that has done enable\_commands. By doing so the object can be found
    by the function find\_living. 

    {\bf Nota Bene: }   This is normally used to allow finding of an npc globally in the
    game.

    {\bf See Also: }    find\_living, find\_player, enable\_commands

    {\bf Caveat: }  If there is two living objects with the same name then only one
    of them will ever be found by find\_living, undefined which one.



\subsection{set\_this\_player - set the current player}

    {\em void set\_this\_player(object liveob)}

    Set the currently active 'command giver' object. The 'command giver'
    is the living object to which all writes goes. It is also relevant
    to add\_action. It is the object returned by this\_player()

    {\bf Nota Bene: }   This is not the same as this\_interactive() which gives the interactive
    object that caused the current execution chain.

    {\bf See Also: }    this\_player, this\_interactive, write, add\_action



\subsection{seteuid - set the effective userid of current object}

    {\em int seteuid(string userid, int zero) }


    {\bf Nota Bene: }
    {\bf See Also: }
    {\bf Caveat: }
    {\bf Bugs: }

\subsection{setuid - set the userid of the current object to its creator}

    {\em void setuid()}


    {\bf Nota Bene: }
    {\bf See Also: }
    {\bf Caveat: }
    {\bf Bugs: }

\subsection{shadow - let the current object shadow another object or find a shadow}

    {\em object shadow(object shadowee, int setshadow)}


    {\bf Nota Bene: }
    {\bf See Also: }
    {\bf Caveat: }
    {\bf Bugs: }

\subsection{shutdown - shut down the gamedriver}

    {\em void shutdown()}


    {\bf Nota Bene: }
    {\bf See Also: }
    {\bf Caveat: }
    {\bf Bugs: }

\subsection{sizeof - give the size of an array}

    {\em int sizeof(int foobar|mixed *array)}


    {\bf Nota Bene: }
    {\bf See Also: }
    {\bf Caveat: }
    {\bf Bugs: }

\subsection{snoop - let one player snoop another}

    {\em object snoop(void|object snooper, object snoopee)}


    {\bf Nota Bene: }
    {\bf See Also: }
    {\bf Caveat: }
    {\bf Bugs: }

\subsection{sort\_array - sort an array through a specific sort function}

    {\em mixed *sort\_array(int|mixed *array, string sortfunc,}
              string|object sortob)

    {\bf Nota Bene: }
    {\bf See Also: }
    {\bf Caveat: }
    {\bf Bugs: }

\subsection{sscanf - Parse a string with a given format}

    {\em int sscanf(string str, string fmt, mixed var1, mixed var2 ...)}


    {\bf Nota Bene: }
    {\bf See Also: }
    {\bf Caveat: }
    {\bf Bugs: }

\subsection{stringp - true if a given variables value is currently a string}

    {\em int stringp(mixed testvar)}

    Returns 1 if the value of 'testvar' is currently of the type string.

    {\bf See Also: }    intp, pointerp, mappingp, objectp



\subsection{strlen - give the length of a string}

    {\em int strlen(int|string str)}

    Gives the length of a string in number of characters. If an integer
    is passed as an argument then 0 is returned.


\subsection{tail - print the last lines of a file}

    {\em void tail(string filename)}

    Writes the approx 1080 last bytes of the file 'filename' to the
    current player, ie this\_player 

    It ensures that it starts writing on a new line.

    {\bf See Also: }    write, cat



\subsection{tell\_object - send message to a specific living object}

    {\em void tell\_object(object liveob, string message)}

    Sends a message directly to the living object 'liveob'. If 'liveob'
    is an interactive object then the message is written directly to
    the socket. If 'liveob' is an npc then the lfun 'catch\_tell' will
    be called with 'message' as parameter.

    {\bf Nota Bene: }   tell\_object as well as write sends unprocessed messages to the
    recieving object. If the mudlib uses processing on messages
    then calling this function will send a raw message.

    {\bf See Also: }    write


\subsection{test\_bit - test a given bit in a bitfield}

    {\em int test\_bit(string bitfield, int bitnum)}

    Tests a bit with the number 'bitnum' in a specifically coded string
    'bitfield'. The bitfield string is a string consisting of writable
    characters. Each character represents six bits.

    test\_bit returns 1 if the bit is set, otherwise 0.

    {\bf Caveat: }  There is a maximum bitindex number which can be changed in config.h
    in the gamedriver source. This constant is normally 1200.



\subsection{this\_interactive - give the originator of the current execution}

    {\em object this\_interactive()}

    Gives the player that is the cause of the current execution chain.
    This is always an interactive player or 0. It is 0 if the current
    execution is caused by heartbeat or callout.

    This is never changed in functions like command, move\_object etc.

    {\bf Nota Bene: }   Do not use this\_interactive as a replacement for this\_player. There
    several occasions when this will cause errors. Most worth noting
    is when a command() is executed. this\_player will then change to 
    reflect the new current player, but this\_interactive will not. 

    {\bf See Also: }    this\_player, set\_this\_player



\subsection{this\_object - give the object pointer to the executing object}

    {\em object this\_object()}

    Gives the object pointer to the object that is currently executing.


\subsection{this\_player - give the current player}

    {\em object this\_player()}

    Gives the currently active player. This can be both an interactive
    player and an npc in the game. this\_player is the object that gets
    all writes and is affected by add\_action.

    {\bf See Also: }    this\_interactive, write, set\_this\_player, add\_action, move\_object



\subsection{throw - cause an execution to terminate with an error}

    {\em void throw(mixed errdata)}

    Terminates the execution with an error message. If a prior catch is
    active then execution will resume after the catch statement.

    {\bf See Also: }    catch



\subsection{time - give the current time}

    {\em int time()}

    Gives the current time in number of seconds passed since January 1970,
    something. 

    {\bf See Also: }    ctime, file\_time, object\_time

    {\bf Bugs: }    The actual time is only updated in the gamedriver each heartbeat.
    This means that time makes 'leaps' every heartbeat.



\subsection{trace - let a player get trace information }

    {\em int trace(int bitflags)}

    Sets the trace level for the current player. As long as this player
    is current the gamedriver will write trace information. This can
    be very excessive information. The bitcodes are as follows:
    \begin{itemize}
    \item{\bf 1} Trace all calls
    \item{\bf 2} Trace all call\_others
    \item{\bf 4} Trace all returns
    \item{\bf 8} Write arguments when tracing call / call\_other
    \item{\bf 16} Trace stackcode execution (VERY MUCH INFORMATION)
    \item{\bf 32} Trace code in run in heartbeat
    \item{\bf 64} Trace all applys
    \item{\bf 128} Write objectnames when tracing
    \end{itemize}

    {\bf Nota Bene: }   This can most often only be used by some high level wizards in a mud
    for reasons of efficiency. This is implemented through the master
    object

    {\bf See Also: }    traceprefix

    {\bf Bugs: }    When very much information is printed it most often gets discarded
    because the socket can't keep up.


\subsection{traceprefix - set the prefix for objects printed during a trace}

    {\em string traceprefix(int|string prefix)}

    Sets the filenameprefix for objects that should be printed in trace.

    {\bf Nota Bene: }   Use this with caution as it is severly punishing on execution speed.

    {\bf See Also: }    trace


\subsection{unique\_array - Sort an array into arrays of unique groups}

    {\em mixed *unique\_array(int|mixed *array, string uniqfunc, void|mixed del)}

    Gives an array of arrays of nonunique objects. The function 'uniqfunc'
    is called on each of the objects in the array. The return values are
    used to group the objects into a number of arrays. For each object
    in such a subarray 'uniqfunc' returned the same value.

    Then an array on the below form are returned:
   
   \begin{verbatim}
       ({
       ({Same1:1, Same1:2, Same1:3, .... Same1:N }),
       ({Same2:1, Same2:2, Same2:3, .... Same2:N }),
       ({Same3:1, Same3:2, Same3:3, .... Same3:N }),
       ....
       ....
       ({SameM:1, SameM:2, SameM:3, .... SameM:N }),
       })
    \end{verbatim}
   
    {\bf Caveat: }  All elements of the array that is not objectpointers are ignored.

    {\bf Bugs: }

\subsection{users - give an array of the current players}

    {\em object *users()}

    Gives an array of objectpointers to the currently interactive
    objects. This is most often the playerobjects, unless exec() has
    been run to swap a players interactivity into another object.   



\subsection{version - give the version of the gamedriver}

    {\em string version()}

    Simply returns a string indicating the gamedriver version, this is
    typically on the form: "CD.01.xx", where xx is the current patch-
    level.


\subsection{wizlist - print some statistics on wizards}

    {\em void wizlist(void|string wizname)}

    The function of this efun is obsolete and will be rewritten

    {\bf Nota Bene: }
    {\bf See Also: }
    {\bf Caveat: }
    {\bf Bugs: }

\subsection{write - write data (normally text) to the current player}

    {\em void write(mixed data)}

    Writes data to the current 'command giver', ie the object returned by
    this\_player. Data is normally text.    

    {\bf See Also: }    tell\_object, this\_player, set\_this\_player, this\_interactive


\subsection{write\_bytes - write chars in a given position in a file}

    {\em int write\_bytes(string filename, int position, string text)}

    Write the string 'text' at a given position in a file. If the position
    is negative it is counted backwards from the end of the file.

    If the position is outside the file the nothing is written.

    If the 'text' extends outside the file then the file is extended.

    {\bf Nota Bene: }   Observe that you overwrite existing data in the file. Not like
    write\_file where you only append data at the end.

    {\bf See Also: }    read\_bytes, write\_file, read\_file



\subsection{write\_file - append text to a file}

    {\em int write\_file(string filename, string text)}

    This function appends a given string 'text' to the file 'filename'.

    {\bf Nota Bene: }   If you need to rewrite a file, that is not append but write from
    start, then you have to first remove the file with rm.

    {\bf See Also: }    read\_file, read\_bytes, write\_bytes, rm, rmdir
